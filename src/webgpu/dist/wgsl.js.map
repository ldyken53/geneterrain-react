{"version":3,"sources":["wgsl.tsx"],"names":[],"mappings":";;AAAc,QAAA,eAAe,GAAG,6kDA+C9B,CAAC;AACW,QAAA,iBAAiB,GAAG,ysBAuBhC,CAAC;AACW,QAAA,eAAe,GAAG,mYAgB/B,CAAC;AACY,QAAA,eAAe,GAAG,4/DAiD9B,CAAC;AACW,QAAA,eAAe,GAAG,svBAqB9B,CAAC;AACW,QAAA,eAAe,GAAG,2rHA8F/B,CAAC;AACY,QAAA,SAAS,GAAG,4iDA0CxB,CAAC;AACU,QAAA,SAAS,GAAG,yYAWxB,CAAC;AACW,QAAA,SAAS,GAAG,iiDA0CvB,CAAC;AACU,QAAA,SAAS,GAAG,oGAGvB,CAAC;AACW,QAAA,cAAc,GAAG,uwEAqE9B,CAAC;AACY,QAAA,YAAY,GAAG,wlCA4B5B,CAAC;AACY,QAAA,uBAAuB,GAAG,+4DA4CvC,CAAC;AACY,QAAA,eAAe,GAAG,8qBAqC/B,CAAC","file":"wgsl.js","sourcesContent":["export const  compute_terrain = `// compute terrain wgsl\r\nstruct Node {\r\n    value : f32;\r\n    x : f32;\r\n    y : f32;\r\n    size : f32;\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>;\r\n};\r\nstruct Uniforms {\r\n  image_width : u32;\r\n  image_height : u32;\r\n  nodes_length : u32;\r\n  width_factor : f32;\r\n  view_box : vec4<f32>;\r\n};\r\nstruct Pixels {\r\n    pixels : array<f32>;\r\n};\r\nstruct Range {\r\n    x : atomic<i32>;\r\n    y : atomic<i32>;\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(1) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(2) var<storage, write> pixels : Pixels;\r\n@group(0) @binding(3) var<storage, read_write> range : Range;\r\n\r\n@stage(compute) @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\r\n    var x : f32 = f32(global_id.x) / f32(uniforms.image_width);\r\n    var y : f32 = f32(global_id.y) / f32(uniforms.image_height);\r\n    x = x * (uniforms.view_box.z - uniforms.view_box.x) + uniforms.view_box.x;\r\n    y = y * (uniforms.view_box.w - uniforms.view_box.y) + uniforms.view_box.y;\r\n    var value : f32 = 0.0;\r\n\r\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\r\n        var sqrDistance : f32 = (x - nodes.nodes[i].x) * (x - nodes.nodes[i].x) + (y - nodes.nodes[i].y) * (y - nodes.nodes[i].y);\r\n        value = value + nodes.nodes[i].value / (sqrDistance * uniforms.width_factor + 1.0);\r\n    }\r\n    value = value * 100.0;\r\n    atomicMin(&range.x, i32(floor(value)));\r\n    atomicMax(&range.y, i32(ceil(value)));\r\n    pixels.pixels[pixel_index] = value;\r\n}`;\r\nexport const  normalize_terrain = `// normalize terrain wgsl\r\nstruct Uniforms {\r\n  image_width : u32;\r\n  image_height : u32;\r\n  nodes_length : u32;\r\n  width_factor : f32;\r\n};\r\nstruct Pixels {\r\n    pixels : array<f32>;\r\n};\r\nstruct Range {\r\n    x : i32;\r\n    y : i32;\r\n};\r\n\r\n@group(0) @binding(0) var<storage, write> pixels : Pixels;\r\n@group(0) @binding(1) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(2) var<storage, read_write> range : Range;\r\n\r\n@stage(compute) @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\r\n    pixels.pixels[pixel_index] = (pixels.pixels[pixel_index] - f32(range.x)) / f32(range.y - range.x);\r\n}`;\r\nexport const  display_2d_vert = `// Vertex shader\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>;\r\n  @location(0) fragPosition: vec4<f32>;\r\n};\r\n\r\n@stage(vertex)\r\nfn main(@location(0) position : vec4<f32>)\r\n     -> VertexOutput {\r\n    var output : VertexOutput;\r\n    output.Position = position;\r\n    output.fragPosition = 0.5 * (position + vec4<f32>(1.0, 1.0, 1.0, 1.0));\r\n    return output;\r\n}\r\n\r\n\r\n`;\r\nexport const  display_2d_frag = `// Fragment shader\r\nstruct Pixels {\r\n    pixels : array<f32>;\r\n};\r\nstruct Uniforms {\r\n    peak_value : f32;\r\n    valley_value : f32;\r\n};\r\nstruct Image {\r\n    width : u32;\r\n    height : u32;\r\n};\r\n\r\n@group(0) @binding(0) var myTexture: texture_2d<f32>;\r\n@group(0) @binding(1) var<storage, read> pixels : Pixels;\r\n@group(0) @binding(2) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(3) var<uniform> image_size : Image;\r\n\r\nfn outside_grid(p : vec2<u32>) -> bool {\r\n    return any(p == vec2<u32>(u32(0))) || p.x == image_size.width || p.y == image_size.height;\r\n}\r\n\r\n@stage(fragment)\r\nfn main(@location(0) fragPosition: vec4<f32>) -> @location(0) vec4<f32> {\r\n    var ufragPos : vec4<u32> = vec4<u32>(fragPosition * f32(image_size.width));\r\n    var pixelIndex : u32 = ufragPos.x + ufragPos.y * image_size.width;\r\n    var value : f32 = pixels.pixels[pixelIndex];\r\n    if (!outside_grid(ufragPos.xy)){\r\n        var neighbor_peaks : vec4<bool> = vec4<bool>(\r\n            pixels.pixels[pixelIndex - image_size.width] >= uniforms.peak_value ,\r\n            pixels.pixels[pixelIndex - u32(1)] >= uniforms.peak_value,\r\n            pixels.pixels[pixelIndex + u32(1)] >= uniforms.peak_value,\r\n            pixels.pixels[pixelIndex + image_size.width] >= uniforms.peak_value\r\n        );\r\n        var neighbor_valleys : vec4<bool> = vec4<bool>(\r\n            pixels.pixels[pixelIndex - image_size.width] <= uniforms.valley_value,\r\n            pixels.pixels[pixelIndex - u32(1)] <= uniforms.valley_value,\r\n            pixels.pixels[pixelIndex + u32(1)] <= uniforms.valley_value,\r\n            pixels.pixels[pixelIndex + image_size.width] <= uniforms.valley_value\r\n        ); \r\n        if (any(neighbor_peaks) && value < uniforms.peak_value) {\r\n            return vec4<f32>(0.8, 0.5, 0.5, 1.0);\r\n        }\r\n        if (any(neighbor_valleys) && value > uniforms.valley_value) {\r\n            return vec4<f32>(0.5, 0.3, 0.3, 1.0);\r\n        }\r\n    }\r\n    var color : vec4<f32> = textureLoad(myTexture, vec2<i32>(i32(value * 180.0), 1), 0);\r\n    return color;\r\n}`;\r\nexport const  display_3d_vert = `// Vertex shader\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>;\r\n  @location(0) vray_dir: vec3<f32>;\r\n  @location(1) @interpolate(flat) transformed_eye: vec3<f32>;\r\n};\r\nstruct Uniforms {\r\n  proj_view : mat4x4<f32>;\r\n  eye_pos : vec4<f32>;\r\n};\r\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\r\n\r\n[[stage(vertex)]]\r\nfn main(@location(0) position : vec3<f32>)\r\n     -> VertexOutput {\r\n    var output : VertexOutput;\r\n    var volume_translation : vec3<f32> = vec3<f32>(-0.5, -0.5, -0.5);\r\n    output.Position = uniforms.proj_view * vec4<f32>(position + volume_translation, 1.0);\r\n    output.transformed_eye = uniforms.eye_pos.xyz - volume_translation;\r\n    output.vray_dir = position - output.transformed_eye;\r\n    return output;\r\n}`;\r\nexport const  display_3d_frag = `// Fragment shader\r\nstruct Pixels {\r\n    pixels : array<f32>;\r\n};\r\nstruct Image {\r\n    width : u32;\r\n    height : u32;\r\n};\r\n\r\n@group(0) @binding(1) var colormap: texture_2d<f32>;\r\n@group(0) @binding(2) var<storage, read> pixels : Pixels;\r\n@group(0) @binding(3) var<uniform> image_size : Image;\r\n\r\nfn intersect_box(orig : vec3<f32>, dir : vec3<f32>, box_min : vec3<f32>, box_max : vec3<f32>) -> vec2<f32> {\r\n    let inv_dir : vec3<f32> = 1.0 / dir;\r\n    let tmin_tmp : vec3<f32> = (box_min - orig) * inv_dir;\r\n    let tmax_tmp : vec3<f32> = (box_max - orig) * inv_dir;\r\n    var tmin : vec3<f32> = min(tmin_tmp, tmax_tmp);\r\n    var tmax : vec3<f32> = max(tmin_tmp, tmax_tmp);\r\n    var t0 : f32 = max(tmin.x, max(tmin.y, tmin.z));\r\n    var t1 : f32 = min(tmax.x, min(tmax.y, tmax.z));\r\n    return vec2<f32>(t0, t1);\r\n}\r\n\r\nfn outside_grid(p : vec3<f32>, volumeDims : vec3<f32>) -> bool {\r\n    return any(p < vec3<f32>(0.0)) || any(p >= volumeDims);\r\n}\r\n\r\n@stage(fragment)\r\nfn main(\r\n  @location(0) vray_dir: vec3<f32>, \r\n  @location(1) @interpolate(flat) transformed_eye : vec3<f32>\r\n)-> @location(0) vec4<f32> {\r\n    var ray_dir : vec3<f32> = normalize(vray_dir);\r\n    var longest_axis : f32 = f32(max(image_size.width, image_size.height));\r\n    let volume_dims : vec3<f32> = vec3<f32>(f32(image_size.width), f32(image_size.height), f32(longest_axis));\r\n    let vol_eye : vec3<f32> = transformed_eye * volume_dims;\r\n    let grid_ray_dir : vec3<f32> = normalize(ray_dir * volume_dims);\r\n\r\n    var t_hit : vec2<f32> = intersect_box(vol_eye, grid_ray_dir, vec3<f32>(0.0), volume_dims - 1.0);\r\n    if (t_hit.x > t_hit.y) { \r\n        discard;\r\n    }\r\n\r\n    t_hit.x = max(t_hit.x, 0.0);\r\n\r\n    var p : vec3<f32> = (vol_eye + t_hit.x * grid_ray_dir);\r\n    p = clamp(p, vec3<f32>(0.0), volume_dims - 2.0);\r\n    let inv_grid_ray_dir : vec3<f32> = 1.0 / grid_ray_dir;\r\n    let start_cell : vec3<f32> = floor(p);\r\n    let t_max_neg : vec3<f32> = (start_cell - vol_eye) * inv_grid_ray_dir;\r\n    let t_max_pos : vec3<f32> = (start_cell + 1.0 - vol_eye) * inv_grid_ray_dir;\r\n    let is_neg_dir : vec3<f32> = vec3<f32>(grid_ray_dir < vec3<f32>(0.0));\r\n    // Pick between positive/negative t_max based on the ray sign\r\n    var t_max : vec3<f32> = mix(t_max_pos, t_max_neg, is_neg_dir);\r\n    let grid_step : vec3<i32> = vec3<i32>(sign(grid_ray_dir));\r\n    // Note: each voxel is a 1^3 box on the grid\r\n    let t_delta : vec3<f32> = abs(inv_grid_ray_dir);\r\n\r\n    var t_prev : f32 = t_hit.x;\r\n    // Traverse the grid\r\n    loop {\r\n        if (outside_grid(p, volume_dims)) { break; }\r\n        let v000 : vec3<u32> = vec3<u32>(p);\r\n        var pixel_index : u32 = v000.x + v000.y * image_size.width;\r\n        var value : f32 = pixels.pixels[pixel_index];\r\n        if (f32(v000.z) > longest_axis / 2.0) {\r\n            if (value * longest_axis >= f32(v000.z)) {\r\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\r\n            }\r\n        } elseif (f32(v000.z) < longest_axis / 2.0) {\r\n            if (value * longest_axis <= f32(v000.z)) {\r\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\r\n            }\r\n        } else {\r\n            return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\r\n        }\r\n\r\n        let t_next : f32 = min(t_max.x, min(t_max.y, t_max.z));\r\n        t_prev = t_next;\r\n        if (t_next == t_max.x) {\r\n            p.x = p.x + f32(grid_step.x);\r\n            t_max.x = t_max.x + t_delta.x;\r\n        } elseif (t_next == t_max.y) {\r\n            p.y = p.y + f32(grid_step.y);\r\n            t_max.y = t_max.y + t_delta.y;\r\n        } else {\r\n            p.z = p.z + f32(grid_step.z);\r\n            t_max.z = t_max.z + t_delta.z;\r\n        }\r\n    }\r\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\r\n}\r\n\r\n`;\r\nexport const  node_vert = `struct Node {\r\n    value : f32;\r\n    x : f32;\r\n    y : f32;\r\n    size : f32;\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>;\r\n};\r\nstruct VertexOutput {\r\n    @builtin(position) Position : vec4<f32>;\r\n    @location(0) position: vec2<f32>;\r\n    @location(1) @interpolate(flat) center : vec2<f32>;\r\n};\r\nstruct Uniforms {\r\n  view_box : vec4<f32>;\r\n};\r\nstruct Edges {\r\n    edges : array<u32>;\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(1) var<storage, read> nodes : Nodes;\r\n\r\n@stage(vertex)\r\nfn main(@builtin(instance_index) index : u32, @location(0) position : vec2<f32>)\r\n     -> VertexOutput {\r\n    var node_center : vec2<f32> = 2.0 * vec2<f32>(nodes.nodes[index].x, nodes.nodes[index].y) - vec2<f32>(1.0);\r\n    var translation : vec2<f32> = position * 0.01;\r\n    var out_position : vec2<f32> = node_center + translation;\r\n    var output : VertexOutput;\r\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\r\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \r\n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\r\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\r\n    var x : f32 = (out_position.x - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\r\n    var y : f32 = (out_position.y - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\r\n    output.Position = vec4<f32>(x, y, 0.0, 1.0);\r\n    output.position = out_position;\r\n    // flat interpolated position will give bottom right corner, so translate to center\r\n    output.center = node_center;\r\n    return output;\r\n}`;\r\nexport const node_frag = `fn sigmoid(x: f32) -> f32 {\r\n    return 1.0 / (1.0 + exp(-1.0 * x));\r\n}\r\n\r\n@stage(fragment)\r\nfn main(@location(0) position: vec2<f32>, @location(1) @interpolate(flat) center: vec2<f32>) -> @location(0) vec4<f32> {\r\n    if (distance(position, center) > 0.01) {\r\n        discard;\r\n    }\r\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0 - sigmoid(16.0 * distance(position, center) * 50.0 - 12.0));\r\n}\r\n`;\r\nexport const edge_vert = `//this builtin(position) clip_position tells that clip_position is the value we want to use for our vertex position or clip position\r\n//it's not needed to create a struct, we could just do [[builtin(position)]] clipPosition\r\nstruct VertexOutput{\r\n    @builtin(position) clip_position: vec4<f32>;\r\n};\r\nstruct Uniforms {\r\n  view_box : vec4<f32>;\r\n};\r\nstruct Node {\r\n    value : f32;\r\n    x : f32;\r\n    y : f32;\r\n    size : f32;\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>;\r\n};\r\n// struct Edge {\r\n//     source: u32;\r\n//     target: u32;\r\n//     padding1: u32;\r\n//     padding2: u32;\r\n// };\r\nstruct Edges {\r\n    edges : array<u32>;\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(1) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(2) var<storage, read> edges : Edges;\r\n@stage(vertex)\r\nfn main(@builtin(instance_index) index : u32,  @builtin(vertex_index) vidx : u32)-> VertexOutput {\r\n    var out : VertexOutput;\r\n    var node : Node = nodes.nodes[edges.edges[(u32(2.0) *index) + vidx]];\r\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\r\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \r\n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\r\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\r\n    var x : f32 = ((2.0 * node.x - 1.0) - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\r\n    var y : f32 = ((2.0 * node.y - 1.0) - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\r\n    out.clip_position = vec4<f32>(x, y, 0.0, 1.0);\r\n    return out;\r\n}`;\r\nexport const edge_frag = `@stage(fragment)\r\nfn main()->@location(0) vec4<f32>{\r\n    return vec4<f32>(1.0, 0.0, 0.0, 0.2);\r\n}`;\r\nexport const  compute_forces = `struct Node {\r\n    value : f32;\r\n    x : f32;\r\n    y : f32;\r\n    size : f32;\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>;\r\n};\r\nstruct Edges {\r\n    edges : array<u32>;\r\n};\r\nstruct Forces {\r\n    forces : array<f32>;\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32;\r\n    edges_length : u32;\r\n    cooling_factor : f32;\r\n    ideal_length : f32;\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(1) var<storage, read> adjmat : Edges;\r\n@group(0) @binding(2) var<storage, write> forces : Forces;\r\n@group(0) @binding(3) var<uniform> uniforms : Uniforms;\r\n\r\nfn get_bit_selector(bit_index : u32) -> u32 {\r\n    return 1u << bit_index;\r\n}\r\n\r\nfn get_nth_bit(packed : u32, bit_index : u32) -> u32 {\r\n    return packed & get_bit_selector(bit_index);\r\n}\r\n\r\n@stage(compute) @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    let l : f32 = uniforms.ideal_length;\r\n    let node : Node = nodes.nodes[global_id.x];\r\n    var r_force : vec2<f32> = vec2<f32>(0.0, 0.0);\r\n    var a_force : vec2<f32> = vec2<f32>(0.0, 0.0);\r\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\r\n        if (i == global_id.x) {\r\n            continue;\r\n        }\r\n        var node2 : Node = nodes.nodes[i];\r\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\r\n        if (dist > 0.0){\r\n            if (get_nth_bit(adjmat.edges[(i * uniforms.nodes_length + global_id.x) / 32u], (i * uniforms.nodes_length + global_id.x) % 32u) != 0u) {\r\n                var dir : vec2<f32> = normalize(vec2<f32>(node2.x, node2.y) - vec2<f32>(node.x, node.y));\r\n                a_force = a_force + ((dist * dist) / l) * dir;\r\n            } else {\r\n                var dir : vec2<f32> = normalize(vec2<f32>(node.x, node.y) - vec2<f32>(node2.x, node2.y));\r\n                r_force = r_force + ((l * l) / dist) * dir;\r\n            }\r\n        }\r\n    }\r\n    var force : vec2<f32> = (a_force + r_force);\r\n    var localForceMag: f32 = length(force); \r\n    if (localForceMag>0.000000001) {\r\n        force = normalize(force) * min(uniforms.cooling_factor, length(force));\r\n    }\r\n    else{\r\n        force.x = 0.0;\r\n        force.y = 0.0;\r\n    }\r\n    forces.forces[global_id.x * 2u] = force.x;\r\n    forces.forces[global_id.x * 2u + 1u] = force.y;\r\n}\r\n`;\r\nexport const  apply_forces = `struct Node {\r\n    value : f32;\r\n    x : f32;\r\n    y : f32;\r\n    size : f32;\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>;\r\n};\r\nstruct Forces {\r\n    forces : array<f32>;\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read_write> nodes : Nodes;\r\n@group(0) @binding(1) var<storage, read_write> forces : Forces;\r\n@stage(compute) @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    nodes.nodes[global_id.x].x = nodes.nodes[global_id.x].x + forces.forces[global_id.x * 2u];\r\n    nodes.nodes[global_id.x].y = nodes.nodes[global_id.x].y + forces.forces[global_id.x * 2u + 1u]; \r\n    forces.forces[global_id.x * 2u] = 0.0;\r\n    forces.forces[global_id.x * 2u + 1u] = 0.0;\r\n    // nodes.nodes[global_id.x].x = min(1.0, max(-1.0, nodes.nodes[global_id.x].x));\r\n    // nodes.nodes[global_id.x].y = min(1.0, max(-1.0, nodes.nodes[global_id.x].y));\r\n    // nodes.nodes[global_id.x].x = nodes.nodes[global_id.x].x + 0.01;\r\n    // nodes.nodes[global_id.x].y = nodes.nodes[global_id.x].y + 0.01;\r\n    // var test : f32 = forces.forces[0]; \r\n    // var test2 : f32 = nodes.nodes[0].x;\r\n}\r\n`;\r\nexport const  create_adjacency_matrix = `struct Edges {\r\n    edges : array<u32>;\r\n};\r\nstruct BoolArray {\r\n    matrix : array<u32>;\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32;\r\n    edges_length : u32;\r\n    cooling_factor : f32;\r\n    ideal_length : f32;\r\n};\r\nstruct IntArray {\r\n    matrix : array<i32>;\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> edges : Edges;\r\n@group(0) @binding(1) var<storage, read_write> adjmat : BoolArray;\r\n@group(0) @binding(2) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(3) var<storage, read_write> laplacian : IntArray;\r\n\r\nfn get_bit_selector(bit_index : u32) -> u32 {\r\n    return 1u << bit_index;\r\n}\r\n\r\nfn set_nth_bit(packed : u32, bit_index : u32) -> u32{\r\n    return packed | get_bit_selector(bit_index);\r\n}\r\n\r\n@stage(compute) @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    for (var i : u32 = 0u; i < uniforms.edges_length; i = i + 2u) {\r\n        var source : u32 = edges.edges[i];\r\n        var target : u32 = edges.edges[i + 1u];\r\n        adjmat.matrix[(source * uniforms.nodes_length + target) / 32u] = set_nth_bit(adjmat.matrix[(source * uniforms.nodes_length + target) / 32u], (source * uniforms.nodes_length + target) % 32u);\r\n        adjmat.matrix[(target * uniforms.nodes_length + source) / 32u] = set_nth_bit(adjmat.matrix[(target * uniforms.nodes_length + source) / 32u], (target * uniforms.nodes_length + source) % 32u);\r\n        if (laplacian.matrix[source * uniforms.nodes_length + target] != -1 && source != target) {\r\n            laplacian.matrix[source * uniforms.nodes_length + target] = -1;\r\n            laplacian.matrix[target * uniforms.nodes_length + source] = -1;\r\n            laplacian.matrix[source * uniforms.nodes_length + source] = laplacian.matrix[source * uniforms.nodes_length + source] + 1;\r\n            laplacian.matrix[target * uniforms.nodes_length + target] = laplacian.matrix[target * uniforms.nodes_length + target] + 1;\r\n        }\r\n    } \r\n}\r\n`;\r\nexport const  create_quadtree = `struct Rectangle {\r\n    x : f32;\r\n    y : f32;\r\n    w : f32;\r\n    h : f32;\r\n};\r\nstruct Point {\r\n    x : f32;\r\n    y : f32;\r\n}\r\nstruct QuadTree {\r\n    boundary : Rectangle;\r\n    CoM : Point;\r\n    mass : f32;\r\n    // NE : ptr<function, i32>;\r\n    // NW : ptr<function, i32>;\r\n    // SE : ptr<function, i32>;\r\n    // SW : ptr<function, i32>;\r\n};\r\nstruct BoolArray {\r\n    matrix : array<u32>;\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32;\r\n    edges_length : u32;\r\n    cooling_factor : f32;\r\n    ideal_length : f32;\r\n};\r\nstruct IntArray {\r\n    matrix : array<i32>;\r\n};\r\n\r\n\r\n@stage(compute) @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n\r\n}\r\n`;\r\n"]}