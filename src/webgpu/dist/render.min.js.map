{"version":3,"sources":["render.tsx"],"names":["ez_canvas_controller_1","require","terrain_generator_1","wgsl_1","file_saver_1","force_directed_1","Renderer","adapter","device","canvasRef","colormap","colormapImage","outCanvasRef","fpsRef","iterRef","this","uniform2DBuffer","terrainGenerator","forceDirected","bindGroup2D","nodeBindGroup","edgeBindGroup","nodeDataBuffer","edgeDataBuffer","colorTexture","viewBoxBuffer","nodePipeline","edgePipeline","nodeLength","edgeLength","rangeBuffer","nodeToggle","terrainToggle","edgeToggle","canvasSize","idealLength","coolingFactor","current","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","width","height","configure","format","size","createBuffer","usage","GPUBufferUsage","STORAGE","COPY_DST","mappedAtCreation","Float32Array","getMappedRange","set","unmap","createRenderPipeline","vertex","module","createShaderModule","code","edge_vert","entryPoint","buffers","arrayStride","attributes","offset","shaderLocation","fragment","edge_frag","targets","blend","color","srcFactor","dstFactor","alpha","primitive","topology","multisample","count","COPY_SRC","nodePositionBuffer","VERTEX","edgePositionBuffer","node_vert","node_frag","pipeline","display_2d_vert","display_2d_frag","dataBuf2D","UNIFORM","queue","writeBuffer","imageSizeBuffer","Uint32Array","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","pixelValueBuffer","translation","newTranslation","controller","Controller","render","mousemove","prev","cur","evt","buttons","change","Math","abs","computeTerrain","undefined","wheel","amt","registerForCanvas","view","sampleCount","frameCount","timeToSecond","requestAnimationFrame","frame","start","performance","now","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","resolveTarget","getCurrentTexture","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","setVertexBuffer","setBindGroup","draw","endPass","submit","finish","onSubmittedWorkDone","_a","sent","end","innerText","prototype","setNodeEdgeData","nodeData","edgeData","length","setWidthFactor","widthFactor","setPeakValue","value","setValleyValue","setCoolingFactor","setIdealLength","setGlobalRange","runForceDirected","runForces","toggleTerrainLayer","toggleNodeLayer","toggleEdgeLayer","setColormap","onSave","gpuReadBuffer","MAP_READ","console","log","copyBufferToBuffer","gpuCommands","mapAsync","GPUMapMode","READ","arrayBuffer","output","drawImage","colorData","getImageData","data","imgData","createImageData","i","j","index","colorIndex","trunc","putImageData","toBlob","saveAs","exports"],"mappings":"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","file":"render.min.js","sourcesContent":["import { Controller } from './ez_canvas_controller';\r\nimport TerrainGenerator from './terrain_generator';\r\nimport { display_2d_vert, display_2d_frag, node_vert, node_frag, edge_vert, edge_frag } from './wgsl';\r\nimport { saveAs } from 'file-saver'; \r\nimport ForceDirected from './force_directed';\r\nimport * as d3 from \"d3\";\r\n\r\nclass Renderer {\r\n  public uniform2DBuffer : GPUBuffer | null = null;\r\n  public terrainGenerator : TerrainGenerator | null = null;\r\n  public forceDirected : ForceDirected | null = null;\r\n  public device : GPUDevice;\r\n  public bindGroup2D : GPUBindGroup | null = null;\r\n  public nodeBindGroup : GPUBindGroup | null = null;\r\n  public edgeBindGroup : GPUBindGroup | null = null;\r\n  public nodeDataBuffer : GPUBuffer | null = null;\r\n  public edgeDataBuffer : GPUBuffer | null = null;\r\n  public colorTexture : GPUTexture | null = null;\r\n  public viewBoxBuffer : GPUBuffer | null = null;\r\n  public nodePipeline : GPURenderPipeline | null = null;\r\n  public edgePipeline : GPURenderPipeline | null = null;\r\n  public nodeLength : number = 1;\r\n  public edgeLength : number = 1;\r\n  public rangeBuffer : GPUBuffer | null = null;\r\n  public nodeToggle : boolean = true;\r\n  public terrainToggle : boolean = false;\r\n  public edgeToggle : boolean = true;\r\n  public colormapImage : HTMLImageElement;\r\n  public outCanvasRef : React.RefObject<HTMLCanvasElement>;\r\n  public canvasSize : [number, number] | null = null;\r\n  public idealLength : number = 0.05;\r\n  public coolingFactor : number = 0.9;\r\n  public iterRef : React.RefObject<HTMLLabelElement>;\r\n\r\n  constructor(\r\n    adapter : GPUAdapter, device : GPUDevice, \r\n    canvasRef : React.RefObject<HTMLCanvasElement>, \r\n    colormap : ImageBitmap, colormapImage : HTMLImageElement,\r\n    outCanvasRef : React.RefObject<HTMLCanvasElement>, \r\n    fpsRef : React.RefObject<HTMLLabelElement>,\r\n    iterRef : React.RefObject<HTMLLabelElement>,\r\n  ) {\r\n    this.iterRef = iterRef;\r\n    this.colormapImage = colormapImage;\r\n    this.outCanvasRef = outCanvasRef\r\n    this.device = device;\r\n    // Check that canvas is active\r\n    if (canvasRef.current === null) return;\r\n    const context = canvasRef.current.getContext('webgpu')!;\r\n  \r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const presentationSize = [\r\n      canvasRef.current.clientWidth * devicePixelRatio,\r\n      canvasRef.current.clientHeight * devicePixelRatio,\r\n    ];\r\n    const presentationFormat = context.getPreferredFormat(adapter);\r\n    this.canvasSize = [\r\n      canvasRef.current.width,\r\n      canvasRef.current.height\r\n    ];\r\n  \r\n    context.configure({\r\n      device,\r\n      format: presentationFormat,\r\n      size: presentationSize,\r\n    });\r\n\r\n    this.edgeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true\r\n    });\r\n\r\n    let edgeData = [0, 0, 0.01, 0.01];\r\n    new Float32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n\r\n    // setting it to some trivial data so that it won't fail the pipeline before edge data is available\r\n\r\n    this.edgePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: edge_vert\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers:[\r\n          {\r\n            arrayStride: 2 * 4 * 1,\r\n            attributes:[{\r\n              format:\"float32x2\" as GPUVertexFormat,\r\n              offset: 0,\r\n              shaderLocation: 0\r\n            }\r\n            ]\r\n          }\r\n        ]\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: edge_frag\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor},\r\n              alpha: {srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor}\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"line-list\" //triangle-list is default   \r\n      },\r\n      multisample: {\r\n        count: 4\r\n      }\r\n    });\r\n\r\n    this.rangeBuffer = this.device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    var nodePositionBuffer = device.createBuffer({\r\n      size: 6 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true\r\n    });\r\n    new Float32Array(nodePositionBuffer.getMappedRange()).set([\r\n      1, -1,\r\n      -1, -1,\r\n      -1, 1,\r\n      1, -1,\r\n      -1, 1,\r\n      1, 1,\r\n    ]);\r\n    nodePositionBuffer.unmap();\r\n    var edgePositionBuffer = device.createBuffer({\r\n      size: 2 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true\r\n    });\r\n    new Float32Array(edgePositionBuffer.getMappedRange()).set([\r\n      0, 0,\r\n      1, 1,\r\n    ]);\r\n    edgePositionBuffer.unmap();\r\n\r\n    this.nodeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set([\r\n      0.5, 0.5,\r\n      0.5, 0.5,\r\n    ]);\r\n    this.nodeDataBuffer.unmap();\r\n\r\n    this.nodePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: node_vert,\r\n        }),\r\n        entryPoint: 'main',\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              }\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: node_frag,\r\n        }),\r\n        entryPoint: 'main',\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor},\r\n              alpha: {srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor}\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: 'triangle-list',\r\n      },\r\n      multisample: {\r\n        count: 4\r\n      }\r\n    });\r\n  \r\n    const pipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_vert,\r\n        }),\r\n        entryPoint: 'main',\r\n        buffers: [\r\n          {\r\n            arrayStride: 4 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x4\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              }\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_frag,\r\n        }),\r\n        entryPoint: 'main',\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: 'triangle-list',\r\n      },\r\n      multisample: {\r\n        count: 4\r\n      }\r\n    });\r\n\r\n    // Vertices to render\r\n    var dataBuf2D = device.createBuffer({\r\n      size: 6 * 4 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true\r\n    });\r\n    new Float32Array(dataBuf2D.getMappedRange()).set([\r\n      1, -1, 0, 1,  // position\r\n      -1, -1, 0, 1, // position\r\n      -1, 1, 0, 1,   // position\r\n      1, -1, 0, 1,  // position\r\n      -1, 1, 0, 1, // position\r\n      1, 1, 0, 1,   // position\r\n    ]);\r\n    dataBuf2D.unmap();\r\n\r\n    // Set up uniform buffers for bind group\r\n    this.uniform2DBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(this.uniform2DBuffer, 0, new Float32Array([0.8, 0.2]), 0, 2);\r\n    const imageSizeBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM,\r\n      mappedAtCreation: true\r\n    });\r\n    new Uint32Array(imageSizeBuffer.getMappedRange()).set(this.canvasSize!);\r\n    imageSizeBuffer.unmap();\r\n\r\n    // Load colormap texture\r\n    this.colorTexture = device.createTexture({\r\n      size: [colormap.width, colormap.height, 1],\r\n      format: \"rgba8unorm\",\r\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n\r\n    this.terrainGenerator = new TerrainGenerator(device, this.canvasSize![0], this.canvasSize![1]);\r\n    this.forceDirected = new ForceDirected(device);\r\n\r\n    this.bindGroup2D = device.createBindGroup({\r\n      layout: pipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: this.colorTexture.createView(),\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.terrainGenerator.pixelValueBuffer,\r\n          }\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.uniform2DBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 3,\r\n          resource: {\r\n            buffer: imageSizeBuffer,\r\n          }\r\n        }\r\n      ],\r\n    });\r\n    this.viewBoxBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(this.viewBoxBuffer, 0, new Float32Array([0, 0, 1, 1]), 0, 4);\r\n    var translation = [0, 0, 1, 1];\r\n    var newTranslation = [0, 0, 1, 1];\r\n    var controller = new Controller();\r\n    var terrainGenerator = this.terrainGenerator;\r\n    var render = this;\r\n    controller.mousemove = function (prev, cur, evt) {\r\n      if (evt.buttons == 1) {\r\n        var change = [(cur[0] - prev[0]) * (translation[2] - translation[0]) / render.canvasSize![0], (prev[1] - cur[1]) * (translation[3] - translation[1]) / render.canvasSize![1]];\r\n        newTranslation = [newTranslation[0] - change[0], newTranslation[1] - change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]]\r\n        if (Math.abs(newTranslation[0] - translation[0]) > 0.03 * (translation[2] - translation[0]) || Math.abs(newTranslation[1] - translation[1]) > 0.03 * (translation[3] - translation[1])) {\r\n          translation = newTranslation;\r\n          if (render.terrainToggle) {\r\n            terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer, render.nodeLength);\r\n          }\r\n          device.queue.writeBuffer(render.viewBoxBuffer!, 0, new Float32Array(translation), 0, 4);\r\n        }\r\n      }\r\n    };\r\n    controller.wheel = function (amt) {\r\n      var change = [amt / 1000, amt / 1000];\r\n      newTranslation = [newTranslation[0] + change[0], newTranslation[1] + change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]];\r\n      if (newTranslation[2] - newTranslation[0] > 0.01 && newTranslation[3] - newTranslation[1] > 0.01) {\r\n        translation = newTranslation;\r\n        if (render.terrainToggle) {\r\n          terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer, render.nodeLength);\r\n        }\r\n        device.queue.writeBuffer(render.viewBoxBuffer!, 0, new Float32Array(translation), 0, 4);\r\n      } else {\r\n        newTranslation = translation;\r\n      }\r\n    };\r\n    controller.registerForCanvas(canvasRef.current);\r\n    this.nodeBindGroup = device.createBindGroup({\r\n      layout: this.nodePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          }\r\n        }\r\n      ],\r\n    });\r\n    this.edgeBindGroup = device.createBindGroup({\r\n      layout: this.edgePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          }\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer,\r\n          }\r\n        }\r\n      ],\r\n    });\r\n\r\n    const texture = device.createTexture({\r\n      size: presentationSize,\r\n      sampleCount: 4,\r\n      format: presentationFormat,\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    const view = texture.createView();\r\n\r\n    var render = this;\r\n    var frameCount = 0;\r\n    var timeToSecond = 1000;\r\n    async function frame() {\r\n        var start = performance.now();\r\n        // Sample is no longer the active page.\r\n        if (!canvasRef.current) return;\r\n\r\n        const commandEncoder = device.createCommandEncoder();\r\n\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n        colorAttachments: [\r\n          {\r\n            view,\r\n            resolveTarget: context.getCurrentTexture().createView(),\r\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n            storeOp: \"discard\" as GPUStoreOp,\r\n          },\r\n        ],\r\n        };\r\n\r\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n        if (render.terrainToggle) {\r\n          passEncoder.setPipeline(pipeline);\r\n          passEncoder.setVertexBuffer(0, dataBuf2D);\r\n          passEncoder.setBindGroup(0, render.bindGroup2D!);\r\n          passEncoder.draw(6, 1, 0, 0);\r\n        }\r\n        if (render.edgeToggle) {\r\n          passEncoder.setPipeline(render.edgePipeline!);\r\n          passEncoder.setVertexBuffer(0, edgePositionBuffer);\r\n          passEncoder.setBindGroup(0, render.edgeBindGroup!);\r\n          passEncoder.draw(2, render.edgeLength, 0, 0);\r\n        }\r\n        if (render.nodeToggle) {\r\n          passEncoder.setPipeline(render.nodePipeline!);\r\n          passEncoder.setVertexBuffer(0, nodePositionBuffer);\r\n          passEncoder.setBindGroup(0, render.nodeBindGroup!);\r\n          passEncoder.draw(6, render.nodeLength, 0, 0);\r\n        }\r\n        passEncoder.endPass();\r\n  \r\n        device.queue.submit([commandEncoder.finish()]);\r\n        await device.queue.onSubmittedWorkDone();\r\n        var end = performance.now();\r\n        if (timeToSecond - (end - start) < 0) {\r\n          fpsRef.current!.innerText = `FPS: ${frameCount}`;\r\n          timeToSecond = 1000 + (timeToSecond - (end - start));\r\n          frameCount = 0;\r\n        } else {\r\n          timeToSecond -= end - start;\r\n        }\r\n        frameCount += 1;\r\n        requestAnimationFrame(frame);\r\n    }\r\n\r\n    requestAnimationFrame(frame);\r\n\r\n  }\r\n\r\n  setNodeEdgeData(nodeData : Array<number>, edgeData : Array<number>) {\r\n    this.nodeDataBuffer = this.device.createBuffer({\r\n      size: nodeData.length * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\r\n    this.nodeDataBuffer.unmap();\r\n    this.edgeDataBuffer = this.device.createBuffer({\r\n      size: edgeData.length * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Uint32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n    this.edgeBindGroup = this.device.createBindGroup({\r\n      layout: this.edgePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.nodeBindGroup = this.device.createBindGroup({\r\n      layout: this.nodePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.edgeLength = edgeData.length;\r\n    this.nodeLength = nodeData.length / 4;\r\n    // this.terrainGenerator!.computeTerrain(this.nodeDataBuffer, undefined, undefined, this.rangeBuffer, this.nodeLength);\r\n  }\r\n\r\n  setWidthFactor(widthFactor : number) {\r\n    this.terrainGenerator!.computeTerrain(undefined, widthFactor, undefined, this.rangeBuffer, this.nodeLength);\r\n  }\r\n\r\n  setPeakValue(value : number) {\r\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 0, new Float32Array([value]), 0, 1);\r\n  }\r\n\r\n  setValleyValue(value : number) {\r\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 4, new Float32Array([value]), 0, 1);\r\n  }\r\n\r\n  setCoolingFactor(value : number) {\r\n    this.coolingFactor = value;\r\n  }\r\n\r\n  setIdealLength(value : number) {\r\n    this.idealLength = value;\r\n  }\r\n\r\n  setGlobalRange() {\r\n    if (this.rangeBuffer) {\r\n      this.rangeBuffer = null;\r\n    } else {\r\n      this.rangeBuffer = this.device.createBuffer({\r\n        size: 2 * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n      });    \r\n    }\r\n  }\r\n\r\n  async runForceDirected() {\r\n    this.forceDirected!.runForces(this.nodeDataBuffer!, this.edgeDataBuffer!, this.nodeLength, this.edgeLength, this.coolingFactor, this.idealLength, 10000, 100, this.iterRef);\r\n  }\r\n\r\n  toggleTerrainLayer() {\r\n    this.terrainToggle = !this.terrainToggle;\r\n  }\r\n\r\n  toggleNodeLayer() {\r\n    this.nodeToggle = !this.nodeToggle;\r\n  }\r\n\r\n  toggleEdgeLayer() {\r\n    this.edgeToggle = !this.edgeToggle;\r\n  }\r\n\r\n  setColormap(colormap, colormapImage) {\r\n    this.device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture! },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n    this.colormapImage = colormapImage;\r\n  }\r\n\r\n  async onSave() {\r\n    var height = this.outCanvasRef.current!.height;\r\n    var width = this.outCanvasRef.current!.width;\r\n    const gpuReadBuffer = this.device.createBuffer({\r\n      size: width * height * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n    });\r\n    console.log(width, height);\r\n    var commandEncoder = this.device.createCommandEncoder();\r\n    // Encode commands for copying buffer to buffer.\r\n    commandEncoder.copyBufferToBuffer(\r\n      this.terrainGenerator!.pixelValueBuffer /* source buffer */,\r\n      0 /* source offset */,\r\n      gpuReadBuffer /* destination buffer */,\r\n      0 /* destination offset */,\r\n      width * height * 4 /* size */\r\n    );\r\n\r\n    // Submit GPU commands.\r\n    const gpuCommands = commandEncoder.finish();\r\n    this.device.queue.submit([gpuCommands]);\r\n\r\n    // Read buffer.\r\n    await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n    const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n    var output = new Float32Array(arrayBuffer);\r\n    var context = this.outCanvasRef.current!.getContext('2d');\r\n    context!.drawImage(this.colormapImage, 0, 0);\r\n    var colorData = context!.getImageData(0, 0, 180, 1).data;\r\n    var imgData = context!.createImageData(width, height);\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var index = j + i * width;\r\n        var colorIndex = Math.trunc(output[j + (height - 1 - i) * width] * 180) * 4;\r\n        imgData.data[index * 4] = colorData[colorIndex];\r\n        imgData.data[index * 4 + 1] = colorData[colorIndex + 1];\r\n        imgData.data[index * 4 + 2] = colorData[colorIndex + 2];\r\n        imgData.data[index * 4 + 3] = colorData[colorIndex + 3];\r\n      }\r\n    }\r\n    context!.putImageData(imgData, 0, 0);\r\n    this.outCanvasRef.current!.toBlob(function (b) { saveAs(b!, `terrain.png`); }, \"image/png\");\r\n  }\r\n}\r\nexport default Renderer;\r\n\r\n"]}