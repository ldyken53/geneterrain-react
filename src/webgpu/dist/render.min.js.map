{"version":3,"sources":["render.tsx"],"names":["ez_canvas_controller_1","require","terrain_generator_1","wgsl_1","file_saver_1","force_directed_1","Renderer","adapter","device","canvasRef","colormap","colormapImage","outCanvasRef","fpsRef","iterRef","_this","this","uniform2DBuffer","terrainGenerator","forceDirected","bindGroup2D","nodeBindGroup","edgeBindGroup","nodeDataBuffer","edgeDataBuffer","testFrame","colorTexture","viewBoxBuffer","nodePipeline","edgePipeline","nodeLength","edgeLength","rangeBuffer","nodeToggle","terrainToggle","edgeToggle","canvasSize","idealLength","coolingFactor","edgeList","current","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","width","height","configure","format","compositingAlphaMode","size","createBuffer","usage","GPUBufferUsage","STORAGE","COPY_DST","mappedAtCreation","Float32Array","getMappedRange","set","unmap","createRenderPipeline","vertex","module","createShaderModule","code","edge_vert","entryPoint","buffers","arrayStride","attributes","offset","shaderLocation","fragment","edge_frag","targets","blend","color","srcFactor","dstFactor","alpha","primitive","topology","multisample","count","COPY_SRC","nodePositionBuffer","VERTEX","edgePositionBuffer","node_vert","node_frag","pipeline","display_2d_vert","display_2d_frag","dataBuf2D","UNIFORM","queue","writeBuffer","imageSizeBuffer","Uint32Array","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","pixelValueBuffer","translation","newTranslation","controller","Controller","render","mousemove","prev","cur","evt","buttons","change","Math","abs","computeTerrain","undefined","wheel","amt","registerForCanvas","view","sampleCount","frameCount","timeToSecond","__awaiter","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","resolveTarget","getCurrentTexture","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","setVertexBuffer","setBindGroup","draw","endPass","submit","finish","onSubmittedWorkDone","_a","sent","requestAnimationFrame","frame","start","performance","now","end","innerText","prototype","setNodeEdgeData","nodeData","edgeData","destroy","length","setWidthFactor","widthFactor","setPeakValue","value","setValleyValue","setCoolingFactor","setIdealLength","setGlobalRange","runForceDirected","runForces","toggleTerrainLayer","toggleNodeLayer","toggleEdgeLayer","setColormap","onSave","gpuReadBuffer","MAP_READ","console","log","copyBufferToBuffer","gpuCommands","mapAsync","GPUMapMode","READ","arrayBuffer","output","drawImage","colorData","getImageData","data","imgData","createImageData","i","j","index","colorIndex","trunc","putImageData","toBlob","saveAs","exports"],"mappings":"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","file":"render.min.js","sourcesContent":["import { Controller } from './ez_canvas_controller';\r\nimport TerrainGenerator from './terrain_generator';\r\nimport { display_2d_vert, display_2d_frag, node_vert, node_frag, edge_vert, edge_frag } from './wgsl';\r\nimport { saveAs } from 'file-saver'; \r\nimport ForceDirected from \"./force_directed\";\r\n\r\nclass Renderer {\r\n  public uniform2DBuffer: GPUBuffer | null = null;\r\n  public terrainGenerator: TerrainGenerator | null = null;\r\n  public forceDirected: ForceDirected | null = null;\r\n  public device: GPUDevice;\r\n  public bindGroup2D: GPUBindGroup | null = null;\r\n  public nodeBindGroup: GPUBindGroup | null = null;\r\n  public edgeBindGroup: GPUBindGroup | null = null;\r\n  public nodeDataBuffer: GPUBuffer | null = null;\r\n  public edgeDataBuffer: GPUBuffer | null = null;\r\n  public testFrame: (() => Promise<void>) | null = null;\r\n  public colorTexture: GPUTexture | null = null;\r\n  public viewBoxBuffer: GPUBuffer | null = null;\r\n  public nodePipeline: GPURenderPipeline | null = null;\r\n  public edgePipeline: GPURenderPipeline | null = null;\r\n  public nodeLength: number = 1;\r\n  public edgeLength: number = 1;\r\n  public rangeBuffer: GPUBuffer | null = null;\r\n  public nodeToggle: boolean = true;\r\n  public terrainToggle: boolean = false;\r\n  public edgeToggle: boolean = true;\r\n  public colormapImage: HTMLImageElement;\r\n  public outCanvasRef: React.RefObject<HTMLCanvasElement>;\r\n  public canvasSize: [number, number] | null = null;\r\n  public idealLength: number = 0.05;\r\n  public coolingFactor: number = 0.9;\r\n  public iterRef: React.RefObject<HTMLLabelElement>;\r\n  public edgeList: Array<number> = [0];\r\n\r\n  constructor(\r\n    adapter: GPUAdapter,\r\n    device: GPUDevice,\r\n    canvasRef: React.RefObject<HTMLCanvasElement>,\r\n    colormap: ImageBitmap,\r\n    colormapImage: HTMLImageElement,\r\n    outCanvasRef: React.RefObject<HTMLCanvasElement>,\r\n    fpsRef: React.RefObject<HTMLLabelElement>,\r\n    iterRef: React.RefObject<HTMLLabelElement>\r\n  ) {\r\n    this.iterRef = iterRef;\r\n    this.colormapImage = colormapImage;\r\n    this.outCanvasRef = outCanvasRef;\r\n    this.device = device;\r\n\r\n    // Check that canvas is active\r\n    if (canvasRef.current === null) return;\r\n    const context = canvasRef.current.getContext(\"webgpu\")!;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const presentationSize = [\r\n      canvasRef.current.clientWidth * devicePixelRatio,\r\n      canvasRef.current.clientHeight * devicePixelRatio,\r\n    ];\r\n    const presentationFormat = context.getPreferredFormat(adapter);\r\n    this.canvasSize = [canvasRef.current.width, canvasRef.current.height];\r\n\r\n    context.configure({\r\n      device,\r\n      format: presentationFormat,\r\n      compositingAlphaMode: \"premultiplied\",\r\n      size: presentationSize,\r\n    });\r\n\r\n    this.edgeList = [0];\r\n\r\n    this.edgeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    let edgeData = [0, 0, 0.01, 0.01];\r\n    new Float32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n\r\n    // setting it to some trivial data so that it won't fail the pipeline before edge data is available\r\n\r\n    this.edgePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: edge_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4 * 1,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: edge_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n              alpha: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"line-list\", //triangle-list is default\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    this.rangeBuffer = this.device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    var nodePositionBuffer = device.createBuffer({\r\n      size: 6 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    new Float32Array(nodePositionBuffer.getMappedRange()).set([\r\n      1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1,\r\n    ]);\r\n    nodePositionBuffer.unmap();\r\n    var edgePositionBuffer = device.createBuffer({\r\n      size: 2 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(edgePositionBuffer.getMappedRange()).set([0, 0, 1, 1]);\r\n    edgePositionBuffer.unmap();\r\n\r\n    this.nodeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage:\r\n        GPUBufferUsage.STORAGE |\r\n        GPUBufferUsage.COPY_DST |\r\n        GPUBufferUsage.COPY_SRC,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set([\r\n      0.5, 0.5, 0.5, 0.5,\r\n    ]);\r\n    this.nodeDataBuffer.unmap();\r\n\r\n    this.nodePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: node_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: node_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n              alpha: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"triangle-list\",\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    const pipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 4 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x4\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"triangle-list\",\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    // Vertices to render\r\n    var dataBuf2D = device.createBuffer({\r\n      size: 6 * 4 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(dataBuf2D.getMappedRange()).set([\r\n      1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      1,\r\n      0,\r\n      1, // position\r\n      1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      1,\r\n      0,\r\n      1, // position\r\n      1,\r\n      1,\r\n      0,\r\n      1, // position\r\n    ]);\r\n    dataBuf2D.unmap();\r\n\r\n    // Set up uniform buffers for bind group\r\n    this.uniform2DBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(\r\n      this.uniform2DBuffer,\r\n      0,\r\n      new Float32Array([0.8, 0.2]),\r\n      0,\r\n      2\r\n    );\r\n    const imageSizeBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Uint32Array(imageSizeBuffer.getMappedRange()).set(this.canvasSize!);\r\n    imageSizeBuffer.unmap();\r\n\r\n    // Load colormap texture\r\n    this.colorTexture = device.createTexture({\r\n      size: [colormap.width, colormap.height, 1],\r\n      format: \"rgba8unorm\",\r\n      usage:\r\n        GPUTextureUsage.TEXTURE_BINDING |\r\n        GPUTextureUsage.COPY_DST |\r\n        GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n\r\n    this.terrainGenerator = new TerrainGenerator(\r\n      device,\r\n      this.canvasSize![0],\r\n      this.canvasSize![1]\r\n    );\r\n    this.forceDirected = new ForceDirected(device);\r\n\r\n    this.bindGroup2D = device.createBindGroup({\r\n      layout: pipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: this.colorTexture.createView(),\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.terrainGenerator.pixelValueBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.uniform2DBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 3,\r\n          resource: {\r\n            buffer: imageSizeBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.viewBoxBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(\r\n      this.viewBoxBuffer,\r\n      0,\r\n      new Float32Array([0, 0, 1, 1]),\r\n      0,\r\n      4\r\n    );\r\n    var translation = [0, 0, 1, 1];\r\n    var newTranslation = [0, 0, 1, 1];\r\n    var controller = new Controller();\r\n    var terrainGenerator = this.terrainGenerator;\r\n    var render = this;\r\n    controller.mousemove = function (prev, cur, evt) {\r\n      if (evt.buttons == 1) {\r\n        var change = [\r\n          ((cur[0] - prev[0]) * (translation[2] - translation[0])) /\r\n            render.canvasSize![0],\r\n          ((prev[1] - cur[1]) * (translation[3] - translation[1])) /\r\n            render.canvasSize![1],\r\n        ];\r\n        newTranslation = [\r\n          newTranslation[0] - change[0],\r\n          newTranslation[1] - change[1],\r\n          newTranslation[2] - change[0],\r\n          newTranslation[3] - change[1],\r\n        ];\r\n        if (\r\n          Math.abs(newTranslation[0] - translation[0]) >\r\n            0.03 * (translation[2] - translation[0]) ||\r\n          Math.abs(newTranslation[1] - translation[1]) >\r\n            0.03 * (translation[3] - translation[1])\r\n        ) {\r\n          translation = newTranslation;\r\n          if (render.terrainToggle) {\r\n            terrainGenerator!.computeTerrain(\r\n              undefined,\r\n              undefined,\r\n              translation,\r\n              render.rangeBuffer,\r\n              render.nodeLength\r\n            );\r\n          }\r\n          device.queue.writeBuffer(\r\n            render.viewBoxBuffer!,\r\n            0,\r\n            new Float32Array(translation),\r\n            0,\r\n            4\r\n          );\r\n        }\r\n      }\r\n    };\r\n    controller.wheel = function (amt) {\r\n      var change = [amt / 1000, amt / 1000];\r\n      newTranslation = [\r\n        newTranslation[0] + change[0],\r\n        newTranslation[1] + change[1],\r\n        newTranslation[2] - change[0],\r\n        newTranslation[3] - change[1],\r\n      ];\r\n      if (\r\n        newTranslation[2] - newTranslation[0] > 0.01 &&\r\n        newTranslation[3] - newTranslation[1] > 0.01\r\n      ) {\r\n        translation = newTranslation;\r\n        if (render.terrainToggle) {\r\n          terrainGenerator!.computeTerrain(\r\n            undefined,\r\n            undefined,\r\n            translation,\r\n            render.rangeBuffer,\r\n            render.nodeLength\r\n          );\r\n        }\r\n        device.queue.writeBuffer(\r\n          render.viewBoxBuffer!,\r\n          0,\r\n          new Float32Array(translation),\r\n          0,\r\n          4\r\n        );\r\n      } else {\r\n        newTranslation = translation;\r\n      }\r\n    };\r\n    controller.registerForCanvas(canvasRef.current);\r\n    this.nodeBindGroup = device.createBindGroup({\r\n      layout: this.nodePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.edgeBindGroup = device.createBindGroup({\r\n      layout: this.edgePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n\r\n    const texture = device.createTexture({\r\n      size: presentationSize,\r\n      sampleCount: 4,\r\n      format: presentationFormat,\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    const view = texture.createView();\r\n\r\n    var render = this;\r\n    var frameCount = 0;\r\n    var timeToSecond = 1000;\r\n\r\n    async function frame() {\r\n      var start = performance.now();\r\n      // Sample is no longer the active page.\r\n      if (!canvasRef.current) return;\r\n\r\n      const commandEncoder = device.createCommandEncoder();\r\n\r\n      const renderPassDescriptor: GPURenderPassDescriptor = {\r\n        colorAttachments: [\r\n          {\r\n            view,\r\n            resolveTarget: context.getCurrentTexture().createView(),\r\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n            storeOp: \"discard\" as GPUStoreOp,\r\n          },\r\n        ],\r\n      };\r\n\r\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n      if (render.terrainToggle) {\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setVertexBuffer(0, dataBuf2D);\r\n        passEncoder.setBindGroup(0, render.bindGroup2D!);\r\n        passEncoder.draw(6, 1, 0, 0);\r\n      }\r\n      if (render.edgeToggle) {\r\n        passEncoder.setPipeline(render.edgePipeline!);\r\n        passEncoder.setVertexBuffer(0, edgePositionBuffer);\r\n        passEncoder.setBindGroup(0, render.edgeBindGroup!);\r\n        passEncoder.draw(2, render.edgeLength, 0, 0);\r\n      }\r\n      if (render.nodeToggle) {\r\n        passEncoder.setPipeline(render.nodePipeline!);\r\n        passEncoder.setVertexBuffer(0, nodePositionBuffer);\r\n        passEncoder.setBindGroup(0, render.nodeBindGroup!);\r\n        passEncoder.draw(6, render.nodeLength, 0, 0);\r\n      }\r\n      passEncoder.endPass();\r\n\r\n      device.queue.submit([commandEncoder.finish()]);\r\n      await device.queue.onSubmittedWorkDone();\r\n      // console.log(\"rendering task finished for\", render.edgeLength);\r\n      var end = performance.now();\r\n      if (timeToSecond - (end - start) < 0) {\r\n        fpsRef.current!.innerText = `FPS: ${frameCount}`;\r\n        timeToSecond = 1000 + (timeToSecond - (end - start));\r\n        frameCount = 0;\r\n      } else {\r\n        timeToSecond -= end - start;\r\n      }\r\n      frameCount += 1;\r\n      requestAnimationFrame(frame);\r\n    }\r\n\r\n    this.testFrame = async () => {\r\n      const commandEncoder = this.device.createCommandEncoder();\r\n\r\n      const renderPassDescriptor: GPURenderPassDescriptor = {\r\n        colorAttachments: [\r\n          {\r\n            view,\r\n            resolveTarget: context.getCurrentTexture().createView(),\r\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n            storeOp: \"discard\" as GPUStoreOp,\r\n          },\r\n        ],\r\n      };\r\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n      passEncoder.setPipeline(this.edgePipeline!);\r\n      passEncoder.setVertexBuffer(0, edgePositionBuffer);\r\n      passEncoder.setBindGroup(0, this.edgeBindGroup!);\r\n      passEncoder.draw(2, this.edgeLength);\r\n      passEncoder.setPipeline(this.nodePipeline!);\r\n      passEncoder.setVertexBuffer(0, nodePositionBuffer);\r\n      passEncoder.setBindGroup(0, this.nodeBindGroup!);\r\n      passEncoder.draw(6, this.nodeLength);\r\n      passEncoder.endPass();\r\n\r\n      device.queue.submit([commandEncoder.finish()]);\r\n\r\n      await device.queue.onSubmittedWorkDone();\r\n      // await device.queue.onSubmittedWorkDone();\r\n    };\r\n\r\n    requestAnimationFrame(frame);\r\n  }\r\n\r\n  async setNodeEdgeData(nodeData: Array<number>, edgeData: Array<number>) {\r\n    this.edgeList = edgeData;\r\n    this.nodeDataBuffer!.destroy();\r\n    this.edgeDataBuffer!.destroy();\r\n    this.nodeDataBuffer = this.device.createBuffer({\r\n      size: nodeData.length * 4,\r\n      usage:\r\n        GPUBufferUsage.STORAGE |\r\n        GPUBufferUsage.COPY_DST |\r\n        GPUBufferUsage.COPY_SRC,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\r\n    this.nodeDataBuffer.unmap();\r\n    this.edgeDataBuffer = this.device.createBuffer({\r\n      size: edgeData.length * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Uint32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n    this.edgeBindGroup = this.device.createBindGroup({\r\n      layout: this.edgePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.nodeBindGroup = this.device.createBindGroup({\r\n      layout: this.nodePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.edgeLength = edgeData.length;\r\n    this.nodeLength = nodeData.length / 4;\r\n    await this.testFrame!();\r\n    // this.terrainGenerator!.computeTerrain(this.nodeDataBuffer, undefined, undefined, this.rangeBuffer, this.nodeLength);\r\n  }\r\n\r\n  setWidthFactor(widthFactor: number) {\r\n    this.terrainGenerator!.computeTerrain(\r\n      undefined,\r\n      widthFactor,\r\n      undefined,\r\n      this.rangeBuffer,\r\n      this.nodeLength\r\n    );\r\n  }\r\n\r\n  setPeakValue(value: number) {\r\n    this.device.queue.writeBuffer(\r\n      this.uniform2DBuffer!,\r\n      0,\r\n      new Float32Array([value]),\r\n      0,\r\n      1\r\n    );\r\n  }\r\n\r\n  setValleyValue(value: number) {\r\n    this.device.queue.writeBuffer(\r\n      this.uniform2DBuffer!,\r\n      4,\r\n      new Float32Array([value]),\r\n      0,\r\n      1\r\n    );\r\n  }\r\n\r\n  setCoolingFactor(value: number) {\r\n    this.coolingFactor = value;\r\n  }\r\n\r\n  setIdealLength(value: number) {\r\n    this.idealLength = value;\r\n  }\r\n\r\n  setGlobalRange() {\r\n    if (this.rangeBuffer) {\r\n      this.rangeBuffer = null;\r\n    } else {\r\n      this.rangeBuffer = this.device.createBuffer({\r\n        size: 2 * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n      });\r\n    }\r\n  }\r\n\r\n  async runForceDirected() {\r\n    this.forceDirected!.runForces(\r\n      this.nodeDataBuffer!,\r\n      this.edgeDataBuffer!,\r\n      this.nodeLength,\r\n      this.edgeLength,\r\n      this.coolingFactor,\r\n      this.idealLength,\r\n      87,\r\n      100,\r\n      this.iterRef,\r\n      this.edgeList\r\n    );\r\n  }\r\n\r\n  toggleTerrainLayer() {\r\n    this.terrainToggle = !this.terrainToggle;\r\n  }\r\n\r\n  toggleNodeLayer() {\r\n    this.nodeToggle = !this.nodeToggle;\r\n  }\r\n\r\n  toggleEdgeLayer() {\r\n    this.edgeToggle = !this.edgeToggle;\r\n  }\r\n\r\n  setColormap(colormap, colormapImage) {\r\n    this.device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture! },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n    this.colormapImage = colormapImage;\r\n  }\r\n\r\n  async onSave() {\r\n    var height = this.outCanvasRef.current!.height;\r\n    var width = this.outCanvasRef.current!.width;\r\n    const gpuReadBuffer = this.device.createBuffer({\r\n      size: width * height * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n    });\r\n    console.log(width, height);\r\n    var commandEncoder = this.device.createCommandEncoder();\r\n    // Encode commands for copying buffer to buffer.\r\n    commandEncoder.copyBufferToBuffer(\r\n      this.terrainGenerator!.pixelValueBuffer /* source buffer */,\r\n      0 /* source offset */,\r\n      gpuReadBuffer /* destination buffer */,\r\n      0 /* destination offset */,\r\n      width * height * 4 /* size */\r\n    );\r\n\r\n    // Submit GPU commands.\r\n    const gpuCommands = commandEncoder.finish();\r\n    this.device.queue.submit([gpuCommands]);\r\n\r\n    // Read buffer.\r\n    await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n    const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n    var output = new Float32Array(arrayBuffer);\r\n    var context = this.outCanvasRef.current!.getContext(\"2d\");\r\n    context!.drawImage(this.colormapImage, 0, 0);\r\n    var colorData = context!.getImageData(0, 0, 180, 1).data;\r\n    var imgData = context!.createImageData(width, height);\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var index = j + i * width;\r\n        var colorIndex =\r\n          Math.trunc(output[j + (height - 1 - i) * width] * 180) * 4;\r\n        imgData.data[index * 4] = colorData[colorIndex];\r\n        imgData.data[index * 4 + 1] = colorData[colorIndex + 1];\r\n        imgData.data[index * 4 + 2] = colorData[colorIndex + 2];\r\n        imgData.data[index * 4 + 3] = colorData[colorIndex + 3];\r\n      }\r\n    }\r\n    context!.putImageData(imgData, 0, 0);\r\n    this.outCanvasRef.current!.toBlob(function (b) {\r\n      saveAs(b!, `terrain.png`);\r\n    }, \"image/png\");\r\n  }\r\n}\r\nexport default Renderer;\r\n\r\n"]}