{"version":3,"sources":["render.tsx"],"names":["ez_canvas_controller_1","require","terrain_generator_1","wgsl_1","file_saver_1","force_directed_1","Renderer","adapter","device","canvasRef","colormap","colormapImage","outCanvasRef","fpsRef","iterRef","this","uniform2DBuffer","terrainGenerator","forceDirected","bindGroup2D","nodeBindGroup","edgeBindGroup","nodeDataBuffer","edgeDataBuffer","colorTexture","viewBoxBuffer","nodePipeline","edgePipeline","nodeLength","edgeLength","rangeBuffer","nodeToggle","terrainToggle","edgeToggle","canvasSize","idealLength","coolingFactor","current","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","width","height","configure","format","size","createBuffer","usage","GPUBufferUsage","STORAGE","COPY_DST","mappedAtCreation","Float32Array","getMappedRange","set","unmap","createRenderPipeline","vertex","module","createShaderModule","code","edge_vert","entryPoint","buffers","arrayStride","attributes","offset","shaderLocation","fragment","edge_frag","targets","blend","color","srcFactor","dstFactor","alpha","primitive","topology","multisample","count","COPY_SRC","nodePositionBuffer","VERTEX","edgePositionBuffer","node_vert","node_frag","pipeline","display_2d_vert","display_2d_frag","dataBuf2D","UNIFORM","queue","writeBuffer","imageSizeBuffer","Uint32Array","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","pixelValueBuffer","translation","newTranslation","controller","Controller","render","mousemove","prev","cur","evt","buttons","change","Math","abs","computeTerrain","undefined","wheel","amt","registerForCanvas","view","sampleCount","frameCount","timeToSecond","requestAnimationFrame","frame","start","performance","now","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","resolveTarget","getCurrentTexture","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","setVertexBuffer","setBindGroup","draw","endPass","submit","finish","onSubmittedWorkDone","_a","sent","end","innerText","prototype","setNodeEdgeData","nodeData","edgeData","length","setWidthFactor","widthFactor","setPeakValue","value","setValleyValue","setCoolingFactor","setIdealLength","setGlobalRange","runForceDirected","runForces","toggleTerrainLayer","toggleNodeLayer","toggleEdgeLayer","setColormap","onSave","gpuReadBuffer","MAP_READ","console","log","copyBufferToBuffer","gpuCommands","mapAsync","GPUMapMode","READ","arrayBuffer","output","drawImage","colorData","getImageData","data","imgData","createImageData","i","j","index","colorIndex","trunc","putImageData","toBlob","saveAs","exports"],"mappings":"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","file":"render.min.js","sourcesContent":["import { Controller } from './ez_canvas_controller';\r\nimport TerrainGenerator from './terrain_generator';\r\nimport { display_2d_vert, display_2d_frag, node_vert, node_frag, edge_vert, edge_frag } from './wgsl';\r\nimport { saveAs } from 'file-saver'; \r\nimport ForceDirected from './force_directed';\r\nimport * as d3 from \"d3\";\r\n\r\nclass Renderer {\r\n  public uniform2DBuffer: GPUBuffer | null = null;\r\n  public terrainGenerator: TerrainGenerator | null = null;\r\n  public forceDirected: ForceDirected | null = null;\r\n  public device: GPUDevice;\r\n  public bindGroup2D: GPUBindGroup | null = null;\r\n  public nodeBindGroup: GPUBindGroup | null = null;\r\n  public edgeBindGroup: GPUBindGroup | null = null;\r\n  public nodeDataBuffer: GPUBuffer | null = null;\r\n  public edgeDataBuffer: GPUBuffer | null = null;\r\n  public colorTexture: GPUTexture | null = null;\r\n  public viewBoxBuffer: GPUBuffer | null = null;\r\n  public nodePipeline: GPURenderPipeline | null = null;\r\n  public edgePipeline: GPURenderPipeline | null = null;\r\n  public nodeLength: number = 1;\r\n  public edgeLength: number = 1;\r\n  public rangeBuffer: GPUBuffer | null = null;\r\n  public nodeToggle: boolean = true;\r\n  public terrainToggle: boolean = false;\r\n  public edgeToggle: boolean = true;\r\n  public colormapImage: HTMLImageElement;\r\n  public outCanvasRef: React.RefObject<HTMLCanvasElement>;\r\n  public canvasSize: [number, number] | null = null;\r\n  public idealLength: number = 0.05;\r\n  public coolingFactor: number = 0.9;\r\n  public iterRef: React.RefObject<HTMLLabelElement>;\r\n\r\n  constructor(\r\n    adapter: GPUAdapter,\r\n    device: GPUDevice,\r\n    canvasRef: React.RefObject<HTMLCanvasElement>,\r\n    colormap: ImageBitmap,\r\n    colormapImage: HTMLImageElement,\r\n    outCanvasRef: React.RefObject<HTMLCanvasElement>,\r\n    fpsRef: React.RefObject<HTMLLabelElement>,\r\n    iterRef: React.RefObject<HTMLLabelElement>\r\n  ) {\r\n    this.iterRef = iterRef;\r\n    this.colormapImage = colormapImage;\r\n    this.outCanvasRef = outCanvasRef;\r\n    this.device = device;\r\n    // Check that canvas is active\r\n    if (canvasRef.current === null) return;\r\n    const context = canvasRef.current.getContext(\"webgpu\")!;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const presentationSize = [\r\n      canvasRef.current.clientWidth * devicePixelRatio,\r\n      canvasRef.current.clientHeight * devicePixelRatio,\r\n    ];\r\n    const presentationFormat = context.getPreferredFormat(adapter);\r\n    this.canvasSize = [canvasRef.current.width, canvasRef.current.height];\r\n\r\n    context.configure({\r\n      device,\r\n      format: presentationFormat,\r\n      size: presentationSize,\r\n    });\r\n\r\n    this.edgeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    let edgeData = [0, 0, 0.01, 0.01];\r\n    new Float32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n\r\n    // setting it to some trivial data so that it won't fail the pipeline before edge data is available\r\n\r\n    this.edgePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: edge_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4 * 1,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: edge_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n              alpha: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"line-list\", //triangle-list is default\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    this.rangeBuffer = this.device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    var nodePositionBuffer = device.createBuffer({\r\n      size: 6 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(nodePositionBuffer.getMappedRange()).set([\r\n      1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1,\r\n    ]);\r\n    nodePositionBuffer.unmap();\r\n    var edgePositionBuffer = device.createBuffer({\r\n      size: 2 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(edgePositionBuffer.getMappedRange()).set([0, 0, 1, 1]);\r\n    edgePositionBuffer.unmap();\r\n\r\n    this.nodeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set([\r\n      0.5, 0.5, 0.5, 0.5,\r\n    ]);\r\n    this.nodeDataBuffer.unmap();\r\n\r\n    this.nodePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: node_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: node_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n              alpha: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"triangle-list\",\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    const pipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 4 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x4\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"triangle-list\",\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    // Vertices to render\r\n    var dataBuf2D = device.createBuffer({\r\n      size: 6 * 4 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(dataBuf2D.getMappedRange()).set([\r\n      1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      1,\r\n      0,\r\n      1, // position\r\n      1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      1,\r\n      0,\r\n      1, // position\r\n      1,\r\n      1,\r\n      0,\r\n      1, // position\r\n    ]);\r\n    dataBuf2D.unmap();\r\n\r\n    // Set up uniform buffers for bind group\r\n    this.uniform2DBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(\r\n      this.uniform2DBuffer,\r\n      0,\r\n      new Float32Array([0.8, 0.2]),\r\n      0,\r\n      2\r\n    );\r\n    const imageSizeBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Uint32Array(imageSizeBuffer.getMappedRange()).set(this.canvasSize!);\r\n    imageSizeBuffer.unmap();\r\n\r\n    // Load colormap texture\r\n    this.colorTexture = device.createTexture({\r\n      size: [colormap.width, colormap.height, 1],\r\n      format: \"rgba8unorm\",\r\n      usage:\r\n        GPUTextureUsage.TEXTURE_BINDING |\r\n        GPUTextureUsage.COPY_DST |\r\n        GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n\r\n    this.terrainGenerator = new TerrainGenerator(\r\n      device,\r\n      this.canvasSize![0],\r\n      this.canvasSize![1]\r\n    );\r\n    this.forceDirected = new ForceDirected(device);\r\n\r\n    this.bindGroup2D = device.createBindGroup({\r\n      layout: pipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: this.colorTexture.createView(),\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.terrainGenerator.pixelValueBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.uniform2DBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 3,\r\n          resource: {\r\n            buffer: imageSizeBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.viewBoxBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(\r\n      this.viewBoxBuffer,\r\n      0,\r\n      new Float32Array([0, 0, 1, 1]),\r\n      0,\r\n      4\r\n    );\r\n    var translation = [0, 0, 1, 1];\r\n    var newTranslation = [0, 0, 1, 1];\r\n    var controller = new Controller();\r\n    var terrainGenerator = this.terrainGenerator;\r\n    var render = this;\r\n    controller.mousemove = function (prev, cur, evt) {\r\n      if (evt.buttons == 1) {\r\n        var change = [\r\n          ((cur[0] - prev[0]) * (translation[2] - translation[0])) /\r\n            render.canvasSize![0],\r\n          ((prev[1] - cur[1]) * (translation[3] - translation[1])) /\r\n            render.canvasSize![1],\r\n        ];\r\n        newTranslation = [\r\n          newTranslation[0] - change[0],\r\n          newTranslation[1] - change[1],\r\n          newTranslation[2] - change[0],\r\n          newTranslation[3] - change[1],\r\n        ];\r\n        if (\r\n          Math.abs(newTranslation[0] - translation[0]) >\r\n            0.03 * (translation[2] - translation[0]) ||\r\n          Math.abs(newTranslation[1] - translation[1]) >\r\n            0.03 * (translation[3] - translation[1])\r\n        ) {\r\n          translation = newTranslation;\r\n          if (render.terrainToggle) {\r\n            terrainGenerator!.computeTerrain(\r\n              undefined,\r\n              undefined,\r\n              translation,\r\n              render.rangeBuffer,\r\n              render.nodeLength\r\n            );\r\n          }\r\n          device.queue.writeBuffer(\r\n            render.viewBoxBuffer!,\r\n            0,\r\n            new Float32Array(translation),\r\n            0,\r\n            4\r\n          );\r\n        }\r\n      }\r\n    };\r\n    controller.wheel = function (amt) {\r\n      var change = [amt / 1000, amt / 1000];\r\n      newTranslation = [\r\n        newTranslation[0] + change[0],\r\n        newTranslation[1] + change[1],\r\n        newTranslation[2] - change[0],\r\n        newTranslation[3] - change[1],\r\n      ];\r\n      if (\r\n        newTranslation[2] - newTranslation[0] > 0.01 &&\r\n        newTranslation[3] - newTranslation[1] > 0.01\r\n      ) {\r\n        translation = newTranslation;\r\n        if (render.terrainToggle) {\r\n          terrainGenerator!.computeTerrain(\r\n            undefined,\r\n            undefined,\r\n            translation,\r\n            render.rangeBuffer,\r\n            render.nodeLength\r\n          );\r\n        }\r\n        device.queue.writeBuffer(\r\n          render.viewBoxBuffer!,\r\n          0,\r\n          new Float32Array(translation),\r\n          0,\r\n          4\r\n        );\r\n      } else {\r\n        newTranslation = translation;\r\n      }\r\n    };\r\n    controller.registerForCanvas(canvasRef.current);\r\n    this.nodeBindGroup = device.createBindGroup({\r\n      layout: this.nodePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.edgeBindGroup = device.createBindGroup({\r\n      layout: this.edgePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n\r\n    const texture = device.createTexture({\r\n      size: presentationSize,\r\n      sampleCount: 4,\r\n      format: presentationFormat,\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    const view = texture.createView();\r\n\r\n    var render = this;\r\n    var frameCount = 0;\r\n    var timeToSecond = 1000;\r\n    async function frame() {\r\n      var start = performance.now();\r\n      // Sample is no longer the active page.\r\n      if (!canvasRef.current) return;\r\n\r\n      const commandEncoder = device.createCommandEncoder();\r\n\r\n      const renderPassDescriptor: GPURenderPassDescriptor = {\r\n        colorAttachments: [\r\n          {\r\n            view,\r\n            resolveTarget: context.getCurrentTexture().createView(),\r\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n            storeOp: \"discard\" as GPUStoreOp,\r\n          },\r\n        ],\r\n      };\r\n\r\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n      if (render.terrainToggle) {\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setVertexBuffer(0, dataBuf2D);\r\n        passEncoder.setBindGroup(0, render.bindGroup2D!);\r\n        passEncoder.draw(6, 1, 0, 0);\r\n      }\r\n      if (render.edgeToggle) {\r\n        passEncoder.setPipeline(render.edgePipeline!);\r\n        passEncoder.setVertexBuffer(0, edgePositionBuffer);\r\n        passEncoder.setBindGroup(0, render.edgeBindGroup!);\r\n        passEncoder.draw(2, render.edgeLength, 0, 0);\r\n      }\r\n      if (render.nodeToggle) {\r\n        passEncoder.setPipeline(render.nodePipeline!);\r\n        passEncoder.setVertexBuffer(0, nodePositionBuffer);\r\n        passEncoder.setBindGroup(0, render.nodeBindGroup!);\r\n        passEncoder.draw(6, render.nodeLength, 0, 0);\r\n      }\r\n      passEncoder.endPass();\r\n\r\n      device.queue.submit([commandEncoder.finish()]);\r\n      await device.queue.onSubmittedWorkDone();\r\n      var end = performance.now();\r\n      if (timeToSecond - (end - start) < 0) {\r\n        fpsRef.current!.innerText = `FPS: ${frameCount}`;\r\n        timeToSecond = 1000 + (timeToSecond - (end - start));\r\n        frameCount = 0;\r\n      } else {\r\n        timeToSecond -= end - start;\r\n      }\r\n      frameCount += 1;\r\n      requestAnimationFrame(frame);\r\n    }\r\n\r\n    requestAnimationFrame(frame);\r\n  }\r\n\r\n  setNodeEdgeData(nodeData: Array<number>, edgeData: Array<number>) {\r\n    this.nodeDataBuffer = this.device.createBuffer({\r\n      size: nodeData.length * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\r\n    this.nodeDataBuffer.unmap();\r\n    this.edgeDataBuffer = this.device.createBuffer({\r\n      size: edgeData.length * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Uint32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n    this.edgeBindGroup = this.device.createBindGroup({\r\n      layout: this.edgePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.nodeBindGroup = this.device.createBindGroup({\r\n      layout: this.nodePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.edgeLength = edgeData.length;\r\n    this.nodeLength = nodeData.length / 4;\r\n    // this.terrainGenerator!.computeTerrain(this.nodeDataBuffer, undefined, undefined, this.rangeBuffer, this.nodeLength);\r\n  }\r\n\r\n  setWidthFactor(widthFactor: number) {\r\n    this.terrainGenerator!.computeTerrain(\r\n      undefined,\r\n      widthFactor,\r\n      undefined,\r\n      this.rangeBuffer,\r\n      this.nodeLength\r\n    );\r\n  }\r\n\r\n  setPeakValue(value: number) {\r\n    this.device.queue.writeBuffer(\r\n      this.uniform2DBuffer!,\r\n      0,\r\n      new Float32Array([value]),\r\n      0,\r\n      1\r\n    );\r\n  }\r\n\r\n  setValleyValue(value: number) {\r\n    this.device.queue.writeBuffer(\r\n      this.uniform2DBuffer!,\r\n      4,\r\n      new Float32Array([value]),\r\n      0,\r\n      1\r\n    );\r\n  }\r\n\r\n  setCoolingFactor(value: number) {\r\n    this.coolingFactor = value;\r\n  }\r\n\r\n  setIdealLength(value: number) {\r\n    this.idealLength = value;\r\n  }\r\n\r\n  setGlobalRange() {\r\n    if (this.rangeBuffer) {\r\n      this.rangeBuffer = null;\r\n    } else {\r\n      this.rangeBuffer = this.device.createBuffer({\r\n        size: 2 * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n      });\r\n    }\r\n  }\r\n\r\n  async runForceDirected() {\r\n    this.forceDirected!.runForces(\r\n      this.nodeDataBuffer!,\r\n      this.edgeDataBuffer!,\r\n      this.nodeLength,\r\n      this.edgeLength,\r\n      this.coolingFactor,\r\n      this.idealLength,\r\n      10000,\r\n      100,\r\n      this.iterRef\r\n    );\r\n  }\r\n\r\n  toggleTerrainLayer() {\r\n    this.terrainToggle = !this.terrainToggle;\r\n  }\r\n\r\n  toggleNodeLayer() {\r\n    this.nodeToggle = !this.nodeToggle;\r\n  }\r\n\r\n  toggleEdgeLayer() {\r\n    this.edgeToggle = !this.edgeToggle;\r\n  }\r\n\r\n  setColormap(colormap, colormapImage) {\r\n    this.device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture! },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n    this.colormapImage = colormapImage;\r\n  }\r\n\r\n  async onSave() {\r\n    var height = this.outCanvasRef.current!.height;\r\n    var width = this.outCanvasRef.current!.width;\r\n    const gpuReadBuffer = this.device.createBuffer({\r\n      size: width * height * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n    });\r\n    console.log(width, height);\r\n    var commandEncoder = this.device.createCommandEncoder();\r\n    // Encode commands for copying buffer to buffer.\r\n    commandEncoder.copyBufferToBuffer(\r\n      this.terrainGenerator!.pixelValueBuffer /* source buffer */,\r\n      0 /* source offset */,\r\n      gpuReadBuffer /* destination buffer */,\r\n      0 /* destination offset */,\r\n      width * height * 4 /* size */\r\n    );\r\n\r\n    // Submit GPU commands.\r\n    const gpuCommands = commandEncoder.finish();\r\n    this.device.queue.submit([gpuCommands]);\r\n\r\n    // Read buffer.\r\n    await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n    const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n    var output = new Float32Array(arrayBuffer);\r\n    var context = this.outCanvasRef.current!.getContext(\"2d\");\r\n    context!.drawImage(this.colormapImage, 0, 0);\r\n    var colorData = context!.getImageData(0, 0, 180, 1).data;\r\n    var imgData = context!.createImageData(width, height);\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var index = j + i * width;\r\n        var colorIndex =\r\n          Math.trunc(output[j + (height - 1 - i) * width] * 180) * 4;\r\n        imgData.data[index * 4] = colorData[colorIndex];\r\n        imgData.data[index * 4 + 1] = colorData[colorIndex + 1];\r\n        imgData.data[index * 4 + 2] = colorData[colorIndex + 2];\r\n        imgData.data[index * 4 + 3] = colorData[colorIndex + 3];\r\n      }\r\n    }\r\n    context!.putImageData(imgData, 0, 0);\r\n    this.outCanvasRef.current!.toBlob(function (b) {\r\n      saveAs(b!, `terrain.png`);\r\n    }, \"image/png\");\r\n  }\r\n}\r\nexport default Renderer;\r\n\r\n"]}