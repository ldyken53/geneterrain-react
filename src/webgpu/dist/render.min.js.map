{"version":3,"sources":["render.tsx"],"names":["ez_canvas_controller_1","require","terrain_generator_1","wgsl_1","file_saver_1","force_directed_1","Renderer","adapter","device","canvasRef","colormap","colormapImage","outCanvasRef","fpsRef","iterRef","_this","this","uniform2DBuffer","terrainGenerator","forceDirected","bindGroup2D","nodeBindGroup","edgeBindGroup","nodeDataBuffer","edgeDataBuffer","testFrame","colorTexture","viewBoxBuffer","nodePipeline","edgePipeline","nodeLength","edgeLength","rangeBuffer","nodeToggle","terrainToggle","edgeToggle","canvasSize","idealLength","coolingFactor","current","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","width","height","configure","format","size","createBuffer","usage","GPUBufferUsage","STORAGE","COPY_DST","mappedAtCreation","Float32Array","getMappedRange","set","unmap","createRenderPipeline","vertex","module","createShaderModule","code","edge_vert","entryPoint","buffers","arrayStride","attributes","offset","shaderLocation","fragment","edge_frag","targets","blend","color","srcFactor","dstFactor","alpha","primitive","topology","multisample","count","COPY_SRC","nodePositionBuffer","VERTEX","edgePositionBuffer","node_vert","node_frag","pipeline","display_2d_vert","display_2d_frag","dataBuf2D","UNIFORM","queue","writeBuffer","imageSizeBuffer","Uint32Array","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","pixelValueBuffer","translation","newTranslation","controller","Controller","render","mousemove","prev","cur","evt","buttons","change","Math","abs","computeTerrain","undefined","wheel","amt","registerForCanvas","view","sampleCount","__awaiter","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","resolveTarget","getCurrentTexture","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","setVertexBuffer","setBindGroup","draw","endPass","submit","finish","onSubmittedWorkDone","_a","sent","prototype","setNodeEdgeData","nodeData","edgeData","destroy","length","setWidthFactor","widthFactor","setPeakValue","value","setValleyValue","setCoolingFactor","setIdealLength","setGlobalRange","runForceDirected","runForces","toggleTerrainLayer","toggleNodeLayer","toggleEdgeLayer","setColormap","onSave","gpuReadBuffer","MAP_READ","console","log","copyBufferToBuffer","gpuCommands","mapAsync","GPUMapMode","READ","arrayBuffer","output","drawImage","colorData","getImageData","data","imgData","createImageData","i","j","index","colorIndex","trunc","putImageData","toBlob","saveAs","exports"],"mappings":"y7CAAA,IAAAA,uBAAAC,QAAA,0BACAC,oBAAAD,QAAA,uBACAE,OAAAF,QAAA,UACAG,aAAAH,QAAA,cACAI,iBAAAJ,QAAA,oBAEAK,SAAA,WA4BE,SAAAA,EACEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GARF,IAAAC,EAAAC,KAeE,GA1CKA,KAAAC,gBAAoC,KACpCD,KAAAE,iBAA4C,KAC5CF,KAAAG,cAAsC,KAEtCH,KAAAI,YAAmC,KACnCJ,KAAAK,cAAqC,KACrCL,KAAAM,cAAqC,KACrCN,KAAAO,eAAmC,KACnCP,KAAAQ,eAAmC,KACnCR,KAAAS,UAA0C,KAC1CT,KAAAU,aAAkC,KAClCV,KAAAW,cAAkC,KAClCX,KAAAY,aAAyC,KACzCZ,KAAAa,aAAyC,KACzCb,KAAAc,WAAqB,EACrBd,KAAAe,WAAqB,EACrBf,KAAAgB,YAAgC,KAChChB,KAAAiB,YAAsB,EACtBjB,KAAAkB,eAAyB,EACzBlB,KAAAmB,YAAsB,EAGtBnB,KAAAoB,WAAsC,KACtCpB,KAAAqB,YAAsB,IACtBrB,KAAAsB,cAAwB,GAa7BtB,KAAKF,QAAUA,EACfE,KAAKL,cAAgBA,EACrBK,KAAKJ,aAAeA,EACpBI,KAAKR,OAASA,EAEY,OAAtBC,EAAU8B,QAAd,CACA,IAAMC,EAAU/B,EAAU8B,QAAQE,WAAW,UAEvCC,EAAmBC,OAAOD,kBAAoB,EAC9CE,EAAmB,CACvBnC,EAAU8B,QAAQM,YAAcH,EAChCjC,EAAU8B,QAAQO,aAAeJ,GAE7BK,EAAqBP,EAAQQ,mBAAmBzC,GACtDS,KAAKoB,WAAa,CAAC3B,EAAU8B,QAAQU,MAAOxC,EAAU8B,QAAQW,QAE9DV,EAAQW,UAAU,CAChB3C,OAAMA,EACN4C,OAAQL,EACRM,KAAMT,IAGR5B,KAAKQ,eAAiBhB,EAAO8C,aAAa,CACxCD,KAAM,GACNE,MAAOC,eAAeC,QAAUD,eAAeE,SAC/CC,kBAAkB,IAIpB,IAAIC,aAAa5C,KAAKQ,eAAeqC,kBAAkBC,IADxC,CAAC,EAAG,EAAG,IAAM,MAE5B9C,KAAKQ,eAAeuC,QAIpB/C,KAAKa,aAAerB,EAAOwD,qBAAqB,CAC9CC,OAAQ,CACNC,OAAQ1D,EAAO2D,mBAAmB,CAChCC,KAAMjE,OAAAkE,YAERC,WAAY,OACZC,QAAS,CACP,CACEC,YAAa,EACbC,WAAY,CACV,CACErB,OAAQ,YACRsB,OAAQ,EACRC,eAAgB,OAM1BC,SAAU,CACRV,OAAQ1D,EAAO2D,mBAAmB,CAChCC,KAAMjE,OAAA0E,YAERP,WAAY,OACZQ,QAAS,CACP,CACE1B,OAAQL,EACRgC,MAAO,CACLC,MAAO,CACLC,UAAW,MACXC,UAAW,uBAEbC,MAAO,CACLF,UAAW,MACXC,UAAW,2BAMrBE,UAAW,CACTC,SAAU,aAEZC,YAAa,CACXC,MAAO,KAIXvE,KAAKgB,YAAchB,KAAKR,OAAO8C,aAAa,CAC1CD,KAAM,EACNE,MAAOC,eAAeC,QAAUD,eAAegC,WAGjD,IAAIC,EAAqBjF,EAAO8C,aAAa,CAC3CD,KAAM,GACNE,MAAOC,eAAekC,OACtB/B,kBAAkB,IAGpB,IAAIC,aAAa6B,EAAmB5B,kBAAkBC,IAAI,CACxD,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,IAEzC2B,EAAmB1B,QACnB,IAAI4B,EAAqBnF,EAAO8C,aAAa,CAC3CD,KAAM,GACNE,MAAOC,eAAekC,OACtB/B,kBAAkB,IAEpB,IAAIC,aAAa+B,EAAmB9B,kBAAkBC,IAAI,CAAC,EAAG,EAAG,EAAG,IACpE6B,EAAmB5B,QAEnB/C,KAAKO,eAAiBf,EAAO8C,aAAa,CACxCD,KAAM,GACNE,MAAOC,eAAeC,QAAUD,eAAeE,SAC/CC,kBAAkB,IAEpB,IAAIC,aAAa5C,KAAKO,eAAesC,kBAAkBC,IAAI,CACzD,GAAK,GAAK,GAAK,KAEjB9C,KAAKO,eAAewC,QAEpB/C,KAAKY,aAAepB,EAAOwD,qBAAqB,CAC9CC,OAAQ,CACNC,OAAQ1D,EAAO2D,mBAAmB,CAChCC,KAAMjE,OAAAyF,YAERtB,WAAY,OACZC,QAAS,CACP,CACEC,YAAa,EACbC,WAAY,CACV,CACErB,OAAQ,YACRsB,OAAQ,EACRC,eAAgB,OAM1BC,SAAU,CACRV,OAAQ1D,EAAO2D,mBAAmB,CAChCC,KAAMjE,OAAA0F,YAERvB,WAAY,OACZQ,QAAS,CACP,CACE1B,OAAQL,EACRgC,MAAO,CACLC,MAAO,CACLC,UAAW,MACXC,UAAW,uBAEbC,MAAO,CACLF,UAAW,MACXC,UAAW,2BAMrBE,UAAW,CACTC,SAAU,iBAEZC,YAAa,CACXC,MAAO,KAIX,IAAMO,EAAWtF,EAAOwD,qBAAqB,CAC3CC,OAAQ,CACNC,OAAQ1D,EAAO2D,mBAAmB,CAChCC,KAAMjE,OAAA4F,kBAERzB,WAAY,OACZC,QAAS,CACP,CACEC,YAAa,GACbC,WAAY,CACV,CACErB,OAAQ,YACRsB,OAAQ,EACRC,eAAgB,OAM1BC,SAAU,CACRV,OAAQ1D,EAAO2D,mBAAmB,CAChCC,KAAMjE,OAAA6F,kBAER1B,WAAY,OACZQ,QAAS,CACP,CACE1B,OAAQL,KAIdqC,UAAW,CACTC,SAAU,iBAEZC,YAAa,CACXC,MAAO,KAKPU,EAAYzF,EAAO8C,aAAa,CAClCD,KAAM,GACNE,MAAOC,eAAekC,OACtB/B,kBAAkB,IAEpB,IAAIC,aAAaqC,EAAUpC,kBAAkBC,IAAI,CAC/C,GACC,EACD,EACA,GACC,GACA,EACD,EACA,GACC,EACD,EACA,EACA,EACA,GACC,EACD,EACA,GACC,EACD,EACA,EACA,EACA,EACA,EACA,EACA,IAEFmC,EAAUlC,QAGV/C,KAAKC,gBAAkBT,EAAO8C,aAAa,CACzCD,KAAM,EACNE,MAAOC,eAAe0C,QAAU1C,eAAeE,WAEjDlD,EAAO2F,MAAMC,YACXpF,KAAKC,gBACL,EACA,IAAI2C,aAAa,CAAC,GAAK,KACvB,EACA,GAEF,IAAMyC,EAAkB7F,EAAO8C,aAAa,CAC1CD,KAAM,EACNE,MAAOC,eAAe0C,QACtBvC,kBAAkB,IAEpB,IAAI2C,YAAYD,EAAgBxC,kBAAkBC,IAAI9C,KAAKoB,YAC3DiE,EAAgBtC,QAGhB/C,KAAKU,aAAelB,EAAO+F,cAAc,CACvClD,KAAM,CAAC3C,EAASuC,MAAOvC,EAASwC,OAAQ,GACxCE,OAAQ,aACRG,MACEiD,gBAAgBC,gBAChBD,gBAAgB9C,SAChB8C,gBAAgBE,oBAEpBlG,EAAO2F,MAAMQ,2BACX,CAAEC,OAAQlG,GACV,CAAEmG,QAAS7F,KAAKU,cAChB,CAAChB,EAASuC,MAAOvC,EAASwC,OAAQ,IAGpClC,KAAKE,iBAAmB,IAAIhB,oBAAA,QAC1BM,EACAQ,KAAKoB,WAAY,GACjBpB,KAAKoB,WAAY,IAEnBpB,KAAKG,cAAgB,IAAId,iBAAA,QAAcG,GAEvCQ,KAAKI,YAAcZ,EAAOsG,gBAAgB,CACxCC,OAAQjB,EAASkB,mBAAmB,GACpCC,QAAS,CACP,CACEC,QAAS,EACTC,SAAUnG,KAAKU,aAAa0F,cAE9B,CACEF,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKE,iBAAiBoG,mBAGlC,CACEJ,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKC,kBAGjB,CACEiG,QAAS,EACTC,SAAU,CACRE,OAAQhB,OAKhBrF,KAAKW,cAAgBnB,EAAO8C,aAAa,CACvCD,KAAM,GACNE,MAAOC,eAAe0C,QAAU1C,eAAeE,WAEjDlD,EAAO2F,MAAMC,YACXpF,KAAKW,cACL,EACA,IAAIiC,aAAa,CAAC,EAAG,EAAG,EAAG,IAC3B,EACA,GAEF,IAAI2D,EAAc,CAAC,EAAG,EAAG,EAAG,GACxBC,EAAiB,CAAC,EAAG,EAAG,EAAG,GAC3BC,EAAa,IAAIzH,uBAAA0H,WACjBxG,EAAmBF,KAAKE,iBACxByG,EAAS3G,KACbyG,EAAWG,UAAY,SAAUC,EAAMC,EAAKC,GAC1C,GAAmB,GAAfA,EAAIC,QAAc,CACpB,IAAIC,EAAS,EACTH,EAAI,GAAKD,EAAK,KAAON,EAAY,GAAKA,EAAY,IAClDI,EAAOvF,WAAY,IACnByF,EAAK,GAAKC,EAAI,KAAOP,EAAY,GAAKA,EAAY,IAClDI,EAAOvF,WAAY,IAEvBoF,EAAiB,CACfA,EAAe,GAAKS,EAAO,GAC3BT,EAAe,GAAKS,EAAO,GAC3BT,EAAe,GAAKS,EAAO,GAC3BT,EAAe,GAAKS,EAAO,KAG3BC,KAAKC,IAAIX,EAAe,GAAKD,EAAY,IACvC,KAAQA,EAAY,GAAKA,EAAY,KACvCW,KAAKC,IAAIX,EAAe,GAAKD,EAAY,IACvC,KAAQA,EAAY,GAAKA,EAAY,OAEvCA,EAAcC,EACVG,EAAOzF,eACThB,EAAkBkH,oBAChBC,OACAA,EACAd,EACAI,EAAO3F,YACP2F,EAAO7F,YAGXtB,EAAO2F,MAAMC,YACXuB,EAAOhG,cACP,EACA,IAAIiC,aAAa2D,GACjB,EACA,MAKRE,EAAWa,MAAQ,SAAUC,GAC3B,IAAIN,EAAS,CAACM,EAAM,IAAMA,EAAM,KAQU,KAP1Cf,EAAiB,CACfA,EAAe,GAAKS,EAAO,GAC3BT,EAAe,GAAKS,EAAO,GAC3BT,EAAe,GAAKS,EAAO,GAC3BT,EAAe,GAAKS,EAAO,KAGZ,GAAKT,EAAe,IACK,IAAxCA,EAAe,GAAKA,EAAe,IAEnCD,EAAcC,EACVG,EAAOzF,eACThB,EAAkBkH,oBAChBC,OACAA,EACAd,EACAI,EAAO3F,YACP2F,EAAO7F,YAGXtB,EAAO2F,MAAMC,YACXuB,EAAOhG,cACP,EACA,IAAIiC,aAAa2D,GACjB,EACA,IAGFC,EAAiBD,GAGrBE,EAAWe,kBAAkB/H,EAAU8B,SACvCvB,KAAKK,cAAgBb,EAAOsG,gBAAgB,CAC1CC,OAAQ/F,KAAKY,aAAaoF,mBAAmB,GAC7CC,QAAS,CACP,CACEC,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKW,gBAGjB,CACEuF,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKO,oBAKrBP,KAAKM,cAAgBd,EAAOsG,gBAAgB,CAC1CC,OAAQ/F,KAAKa,aAAamF,mBAAmB,GAC7CC,QAAS,CACP,CACEC,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKW,gBAGjB,CACEuF,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKO,iBAGjB,CACE2F,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKQ,oBAMrB,IAMMiH,EANUjI,EAAO+F,cAAc,CACnClD,KAAMT,EACN8F,YAAa,EACbtF,OAAQL,EACRQ,MAAOiD,gBAAgBE,oBAEJU,aAEjBO,EAAS3G,KAyDbA,KAAKS,UAAY,WAAA,OAAAkH,UAAA5H,OAAA,OAAA,EAAA,gFA0Bf,OAzBM6H,EAAiB5H,KAAKR,OAAOqI,uBAE7BC,EAAgD,CACpDC,iBAAkB,CAChB,CACEN,KAAIA,EACJO,cAAexG,EAAQyG,oBAAoB7B,aAC3C8B,UAAW,CAAEC,EAAG,EAAKC,EAAG,EAAKC,EAAG,EAAKC,EAAG,GACxCC,QAAS,cAITC,EAAcZ,EAAea,gBAAgBX,IACvCY,YAAY1I,KAAKa,cAC7B2H,EAAYG,gBAAgB,EAAGhE,GAC/B6D,EAAYI,aAAa,EAAG5I,KAAKM,eACjCkI,EAAYK,KAAK,EAAG7I,KAAKe,YACzByH,EAAYE,YAAY1I,KAAKY,cAC7B4H,EAAYG,gBAAgB,EAAGlE,GAC/B+D,EAAYI,aAAa,EAAG5I,KAAKK,eACjCmI,EAAYK,KAAK,EAAG7I,KAAKc,YACzB0H,EAAYM,UAEZtJ,EAAO2F,MAAM4D,OAAO,CAACnB,EAAeoB,WAEpC,CAAA,EAAMxJ,EAAO2F,MAAM8D,qCAAnBC,EAAAC,kBA0MN,OAjMQ7J,EAAA8J,UAAAC,gBAAN,SAAsBC,EAAyBC,6GA2D7C,OA1DAvJ,KAAKO,eAAgBiJ,UACrBxJ,KAAKQ,eAAgBgJ,UACrBxJ,KAAKO,eAAiBP,KAAKR,OAAO8C,aAAa,CAC7CD,KAAwB,EAAlBiH,EAASG,OACflH,MAAOC,eAAeC,QAAUD,eAAeE,SAC/CC,kBAAkB,IAEpB,IAAIC,aAAa5C,KAAKO,eAAesC,kBAAkBC,IAAIwG,GAC3DtJ,KAAKO,eAAewC,QACpB/C,KAAKQ,eAAiBR,KAAKR,OAAO8C,aAAa,CAC7CD,KAAwB,EAAlBkH,EAASE,OACflH,MAAOC,eAAeE,SAAWF,eAAeC,QAChDE,kBAAkB,IAEpB,IAAI2C,YAAYtF,KAAKQ,eAAeqC,kBAAkBC,IAAIyG,GAC1DvJ,KAAKQ,eAAeuC,QACpB/C,KAAKM,cAAgBN,KAAKR,OAAOsG,gBAAgB,CAC/CC,OAAQ/F,KAAKa,aAAcmF,mBAAmB,GAC9CC,QAAS,CACP,CACEC,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKW,gBAGjB,CACEuF,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKO,iBAGjB,CACE2F,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKQ,oBAKrBR,KAAKK,cAAgBL,KAAKR,OAAOsG,gBAAgB,CAC/CC,OAAQ/F,KAAKY,aAAcoF,mBAAmB,GAC9CC,QAAS,CACP,CACEC,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKW,gBAGjB,CACEuF,QAAS,EACTC,SAAU,CACRE,OAAQrG,KAAKO,oBAKrBP,KAAKe,WAAawI,EAASE,OAC3BzJ,KAAKc,WAAawI,EAASG,OAAS,EACpC,CAAA,EAAMzJ,KAAKS,2BAAXyI,EAAAC,iBAIF7J,EAAA8J,UAAAM,eAAA,SAAeC,GACb3J,KAAKE,iBAAkBkH,oBACrBC,EACAsC,OACAtC,EACArH,KAAKgB,YACLhB,KAAKc,aAITxB,EAAA8J,UAAAQ,aAAA,SAAaC,GACX7J,KAAKR,OAAO2F,MAAMC,YAChBpF,KAAKC,gBACL,EACA,IAAI2C,aAAa,CAACiH,IAClB,EACA,IAIJvK,EAAA8J,UAAAU,eAAA,SAAeD,GACb7J,KAAKR,OAAO2F,MAAMC,YAChBpF,KAAKC,gBACL,EACA,IAAI2C,aAAa,CAACiH,IAClB,EACA,IAIJvK,EAAA8J,UAAAW,iBAAA,SAAiBF,GACf7J,KAAKsB,cAAgBuI,GAGvBvK,EAAA8J,UAAAY,eAAA,SAAeH,GACb7J,KAAKqB,YAAcwI,GAGrBvK,EAAA8J,UAAAa,eAAA,WACMjK,KAAKgB,YACPhB,KAAKgB,YAAc,KAEnBhB,KAAKgB,YAAchB,KAAKR,OAAO8C,aAAa,CAC1CD,KAAM,EACNE,MAAOC,eAAeC,QAAUD,eAAegC,YAK/ClF,EAAA8J,UAAAc,iBAAN,qGACElK,KAAKG,cAAegK,UAClBnK,KAAKO,eACLP,KAAKQ,eACLR,KAAKc,WACLd,KAAKe,WACLf,KAAKsB,cACLtB,KAAKqB,YACL,IACA,IACArB,KAAKF,kBAITR,EAAA8J,UAAAgB,mBAAA,WACEpK,KAAKkB,eAAiBlB,KAAKkB,eAG7B5B,EAAA8J,UAAAiB,gBAAA,WACErK,KAAKiB,YAAcjB,KAAKiB,YAG1B3B,EAAA8J,UAAAkB,gBAAA,WACEtK,KAAKmB,YAAcnB,KAAKmB,YAG1B7B,EAAA8J,UAAAmB,YAAA,SAAY7K,EAAUC,GACpBK,KAAKR,OAAO2F,MAAMQ,2BAChB,CAAEC,OAAQlG,GACV,CAAEmG,QAAS7F,KAAKU,cAChB,CAAChB,EAASuC,MAAOvC,EAASwC,OAAQ,IAEpClC,KAAKL,cAAgBA,GAGjBL,EAAA8J,UAAAoB,OAAN,qJAuBE,OAtBItI,EAASlC,KAAKJ,aAAa2B,QAASW,OACpCD,EAAQjC,KAAKJ,aAAa2B,QAASU,MACjCwI,EAAgBzK,KAAKR,OAAO8C,aAAa,CAC7CD,KAAMJ,EAAQC,EAAS,EACvBK,MAAOC,eAAeE,SAAWF,eAAekI,WAElDC,QAAQC,IAAI3I,EAAOC,IACf0F,EAAiB5H,KAAKR,OAAOqI,wBAElBgD,mBACb7K,KAAKE,iBAAkBoG,iBACvB,EACAmE,EACA,EACAxI,EAAQC,EAAS,GAIb4I,EAAclD,EAAeoB,SACnChJ,KAAKR,OAAO2F,MAAM4D,OAAO,CAAC+B,IAG1B,CAAA,EAAML,EAAcM,SAASC,WAAWC,cAOxC,IAPA/B,EAAAC,OACM+B,EAAcT,EAAc5H,iBAC9BsI,EAAS,IAAIvI,aAAasI,IAC1B1J,EAAUxB,KAAKJ,aAAa2B,QAASE,WAAW,OAC3C2J,UAAUpL,KAAKL,cAAe,EAAG,GACtC0L,EAAY7J,EAAS8J,aAAa,EAAG,EAAG,IAAK,GAAGC,KAChDC,EAAUhK,EAASiK,gBAAgBxJ,EAAOC,GACrCwJ,EAAI,EAAGA,EAAIxJ,EAAQwJ,IAC1B,IAASC,EAAI,EAAGA,EAAI1J,EAAO0J,IACrBC,EAAQD,EAAID,EAAIzJ,EAChB4J,EACuD,EAAzD3E,KAAK4E,MAA6C,IAAvCX,EAAOQ,GAAKzJ,EAAS,EAAIwJ,GAAKzJ,IAC3CuJ,EAAQD,KAAa,EAARK,GAAaP,EAAUQ,GACpCL,EAAQD,KAAa,EAARK,EAAY,GAAKP,EAAuB,EAAbQ,GACxCL,EAAQD,KAAa,EAARK,EAAY,GAAKP,EAAuB,EAAbQ,GACxCL,EAAQD,KAAa,EAARK,EAAY,GAAKP,EAAuB,EAAbQ,UAG5CrK,EAASuK,aAAaP,EAAS,EAAG,GAClCxL,KAAKJ,aAAa2B,QAASyK,OAAO,SAAU3D,GAC1CjJ,aAAA6M,OAAO5D,EAAI,gBACV,uBAEP/I,EA9vBA,GA+vBA4M,QAAA,QAAe5M","file":"render.min.js","sourcesContent":["import { Controller } from './ez_canvas_controller';\r\nimport TerrainGenerator from './terrain_generator';\r\nimport { display_2d_vert, display_2d_frag, node_vert, node_frag, edge_vert, edge_frag } from './wgsl';\r\nimport { saveAs } from 'file-saver'; \r\nimport ForceDirected from \"./force_directed\";\r\n\r\nclass Renderer {\r\n  public uniform2DBuffer: GPUBuffer | null = null;\r\n  public terrainGenerator: TerrainGenerator | null = null;\r\n  public forceDirected: ForceDirected | null = null;\r\n  public device: GPUDevice;\r\n  public bindGroup2D: GPUBindGroup | null = null;\r\n  public nodeBindGroup: GPUBindGroup | null = null;\r\n  public edgeBindGroup: GPUBindGroup | null = null;\r\n  public nodeDataBuffer: GPUBuffer | null = null;\r\n  public edgeDataBuffer: GPUBuffer | null = null;\r\n  public testFrame: (() => Promise<void>) | null = null;\r\n  public colorTexture: GPUTexture | null = null;\r\n  public viewBoxBuffer: GPUBuffer | null = null;\r\n  public nodePipeline: GPURenderPipeline | null = null;\r\n  public edgePipeline: GPURenderPipeline | null = null;\r\n  public nodeLength: number = 1;\r\n  public edgeLength: number = 1;\r\n  public rangeBuffer: GPUBuffer | null = null;\r\n  public nodeToggle: boolean = true;\r\n  public terrainToggle: boolean = false;\r\n  public edgeToggle: boolean = true;\r\n  public colormapImage: HTMLImageElement;\r\n  public outCanvasRef: React.RefObject<HTMLCanvasElement>;\r\n  public canvasSize: [number, number] | null = null;\r\n  public idealLength: number = 0.05;\r\n  public coolingFactor: number = 0.9;\r\n  public iterRef: React.RefObject<HTMLLabelElement>;\r\n\r\n  constructor(\r\n    adapter: GPUAdapter,\r\n    device: GPUDevice,\r\n    canvasRef: React.RefObject<HTMLCanvasElement>,\r\n    colormap: ImageBitmap,\r\n    colormapImage: HTMLImageElement,\r\n    outCanvasRef: React.RefObject<HTMLCanvasElement>,\r\n    fpsRef: React.RefObject<HTMLLabelElement>,\r\n    iterRef: React.RefObject<HTMLLabelElement>\r\n  ) {\r\n    this.iterRef = iterRef;\r\n    this.colormapImage = colormapImage;\r\n    this.outCanvasRef = outCanvasRef;\r\n    this.device = device;\r\n    // Check that canvas is active\r\n    if (canvasRef.current === null) return;\r\n    const context = canvasRef.current.getContext(\"webgpu\")!;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const presentationSize = [\r\n      canvasRef.current.clientWidth * devicePixelRatio,\r\n      canvasRef.current.clientHeight * devicePixelRatio,\r\n    ];\r\n    const presentationFormat = context.getPreferredFormat(adapter);\r\n    this.canvasSize = [canvasRef.current.width, canvasRef.current.height];\r\n\r\n    context.configure({\r\n      device,\r\n      format: presentationFormat,\r\n      size: presentationSize,\r\n    });\r\n\r\n    this.edgeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    let edgeData = [0, 0, 0.01, 0.01];\r\n    new Float32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n\r\n    // setting it to some trivial data so that it won't fail the pipeline before edge data is available\r\n\r\n    this.edgePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: edge_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4 * 1,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: edge_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n              alpha: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"line-list\", //triangle-list is default\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    this.rangeBuffer = this.device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    var nodePositionBuffer = device.createBuffer({\r\n      size: 6 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    new Float32Array(nodePositionBuffer.getMappedRange()).set([\r\n      1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1,\r\n    ]);\r\n    nodePositionBuffer.unmap();\r\n    var edgePositionBuffer = device.createBuffer({\r\n      size: 2 * 2 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(edgePositionBuffer.getMappedRange()).set([0, 0, 1, 1]);\r\n    edgePositionBuffer.unmap();\r\n\r\n    this.nodeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set([\r\n      0.5, 0.5, 0.5, 0.5,\r\n    ]);\r\n    this.nodeDataBuffer.unmap();\r\n\r\n    this.nodePipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: node_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: node_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n              alpha: {\r\n                srcFactor: \"one\" as GPUBlendFactor,\r\n                dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor,\r\n              },\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"triangle-list\",\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    const pipeline = device.createRenderPipeline({\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_vert,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 4 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x4\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: display_2d_frag,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"triangle-list\",\r\n      },\r\n      multisample: {\r\n        count: 4,\r\n      },\r\n    });\r\n\r\n    // Vertices to render\r\n    var dataBuf2D = device.createBuffer({\r\n      size: 6 * 4 * 4,\r\n      usage: GPUBufferUsage.VERTEX,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(dataBuf2D.getMappedRange()).set([\r\n      1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      1,\r\n      0,\r\n      1, // position\r\n      1,\r\n      -1,\r\n      0,\r\n      1, // position\r\n      -1,\r\n      1,\r\n      0,\r\n      1, // position\r\n      1,\r\n      1,\r\n      0,\r\n      1, // position\r\n    ]);\r\n    dataBuf2D.unmap();\r\n\r\n    // Set up uniform buffers for bind group\r\n    this.uniform2DBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(\r\n      this.uniform2DBuffer,\r\n      0,\r\n      new Float32Array([0.8, 0.2]),\r\n      0,\r\n      2\r\n    );\r\n    const imageSizeBuffer = device.createBuffer({\r\n      size: 2 * 4,\r\n      usage: GPUBufferUsage.UNIFORM,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Uint32Array(imageSizeBuffer.getMappedRange()).set(this.canvasSize!);\r\n    imageSizeBuffer.unmap();\r\n\r\n    // Load colormap texture\r\n    this.colorTexture = device.createTexture({\r\n      size: [colormap.width, colormap.height, 1],\r\n      format: \"rgba8unorm\",\r\n      usage:\r\n        GPUTextureUsage.TEXTURE_BINDING |\r\n        GPUTextureUsage.COPY_DST |\r\n        GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n\r\n    this.terrainGenerator = new TerrainGenerator(\r\n      device,\r\n      this.canvasSize![0],\r\n      this.canvasSize![1]\r\n    );\r\n    this.forceDirected = new ForceDirected(device);\r\n\r\n    this.bindGroup2D = device.createBindGroup({\r\n      layout: pipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: this.colorTexture.createView(),\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.terrainGenerator.pixelValueBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.uniform2DBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 3,\r\n          resource: {\r\n            buffer: imageSizeBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.viewBoxBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n    device.queue.writeBuffer(\r\n      this.viewBoxBuffer,\r\n      0,\r\n      new Float32Array([0, 0, 1, 1]),\r\n      0,\r\n      4\r\n    );\r\n    var translation = [0, 0, 1, 1];\r\n    var newTranslation = [0, 0, 1, 1];\r\n    var controller = new Controller();\r\n    var terrainGenerator = this.terrainGenerator;\r\n    var render = this;\r\n    controller.mousemove = function (prev, cur, evt) {\r\n      if (evt.buttons == 1) {\r\n        var change = [\r\n          ((cur[0] - prev[0]) * (translation[2] - translation[0])) /\r\n            render.canvasSize![0],\r\n          ((prev[1] - cur[1]) * (translation[3] - translation[1])) /\r\n            render.canvasSize![1],\r\n        ];\r\n        newTranslation = [\r\n          newTranslation[0] - change[0],\r\n          newTranslation[1] - change[1],\r\n          newTranslation[2] - change[0],\r\n          newTranslation[3] - change[1],\r\n        ];\r\n        if (\r\n          Math.abs(newTranslation[0] - translation[0]) >\r\n            0.03 * (translation[2] - translation[0]) ||\r\n          Math.abs(newTranslation[1] - translation[1]) >\r\n            0.03 * (translation[3] - translation[1])\r\n        ) {\r\n          translation = newTranslation;\r\n          if (render.terrainToggle) {\r\n            terrainGenerator!.computeTerrain(\r\n              undefined,\r\n              undefined,\r\n              translation,\r\n              render.rangeBuffer,\r\n              render.nodeLength\r\n            );\r\n          }\r\n          device.queue.writeBuffer(\r\n            render.viewBoxBuffer!,\r\n            0,\r\n            new Float32Array(translation),\r\n            0,\r\n            4\r\n          );\r\n        }\r\n      }\r\n    };\r\n    controller.wheel = function (amt) {\r\n      var change = [amt / 1000, amt / 1000];\r\n      newTranslation = [\r\n        newTranslation[0] + change[0],\r\n        newTranslation[1] + change[1],\r\n        newTranslation[2] - change[0],\r\n        newTranslation[3] - change[1],\r\n      ];\r\n      if (\r\n        newTranslation[2] - newTranslation[0] > 0.01 &&\r\n        newTranslation[3] - newTranslation[1] > 0.01\r\n      ) {\r\n        translation = newTranslation;\r\n        if (render.terrainToggle) {\r\n          terrainGenerator!.computeTerrain(\r\n            undefined,\r\n            undefined,\r\n            translation,\r\n            render.rangeBuffer,\r\n            render.nodeLength\r\n          );\r\n        }\r\n        device.queue.writeBuffer(\r\n          render.viewBoxBuffer!,\r\n          0,\r\n          new Float32Array(translation),\r\n          0,\r\n          4\r\n        );\r\n      } else {\r\n        newTranslation = translation;\r\n      }\r\n    };\r\n    controller.registerForCanvas(canvasRef.current);\r\n    this.nodeBindGroup = device.createBindGroup({\r\n      layout: this.nodePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.edgeBindGroup = device.createBindGroup({\r\n      layout: this.edgePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n\r\n    const texture = device.createTexture({\r\n      size: presentationSize,\r\n      sampleCount: 4,\r\n      format: presentationFormat,\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    const view = texture.createView();\r\n\r\n    var render = this;\r\n    var frameCount = 0;\r\n    var timeToSecond = 1000;\r\n    async function frame() {\r\n      var start = performance.now();\r\n      // Sample is no longer the active page.\r\n      if (!canvasRef.current) return;\r\n\r\n      const commandEncoder = device.createCommandEncoder();\r\n\r\n      const renderPassDescriptor: GPURenderPassDescriptor = {\r\n        colorAttachments: [\r\n          {\r\n            view,\r\n            resolveTarget: context.getCurrentTexture().createView(),\r\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n            storeOp: \"discard\" as GPUStoreOp,\r\n          },\r\n        ],\r\n      };\r\n\r\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n      if (render.terrainToggle) {\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setVertexBuffer(0, dataBuf2D);\r\n        passEncoder.setBindGroup(0, render.bindGroup2D!);\r\n        passEncoder.draw(6, 1, 0, 0);\r\n      }\r\n      if (render.edgeToggle) {\r\n        passEncoder.setPipeline(render.edgePipeline!);\r\n        passEncoder.setVertexBuffer(0, edgePositionBuffer);\r\n        passEncoder.setBindGroup(0, render.edgeBindGroup!);\r\n        passEncoder.draw(2, render.edgeLength, 0, 0);\r\n      }\r\n      if (render.nodeToggle) {\r\n        passEncoder.setPipeline(render.nodePipeline!);\r\n        passEncoder.setVertexBuffer(0, nodePositionBuffer);\r\n        passEncoder.setBindGroup(0, render.nodeBindGroup!);\r\n        passEncoder.draw(6, render.nodeLength, 0, 0);\r\n      }\r\n      passEncoder.endPass();\r\n\r\n      device.queue.submit([commandEncoder.finish()]);\r\n      await device.queue.onSubmittedWorkDone();\r\n      // console.log(\"rendering task finished for\", render.edgeLength);\r\n      var end = performance.now();\r\n      if (timeToSecond - (end - start) < 0) {\r\n        fpsRef.current!.innerText = `FPS: ${frameCount}`;\r\n        timeToSecond = 1000 + (timeToSecond - (end - start));\r\n        frameCount = 0;\r\n      } else {\r\n        timeToSecond -= end - start;\r\n      }\r\n      frameCount += 1;\r\n      requestAnimationFrame(frame);\r\n    }\r\n\r\n    this.testFrame = async () => {\r\n      const commandEncoder = this.device.createCommandEncoder();\r\n\r\n      const renderPassDescriptor: GPURenderPassDescriptor = {\r\n        colorAttachments: [\r\n          {\r\n            view,\r\n            resolveTarget: context.getCurrentTexture().createView(),\r\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n            storeOp: \"discard\" as GPUStoreOp,\r\n          },\r\n        ],\r\n      };\r\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n      passEncoder.setPipeline(this.edgePipeline!);\r\n      passEncoder.setVertexBuffer(0, edgePositionBuffer);\r\n      passEncoder.setBindGroup(0, this.edgeBindGroup!);\r\n      passEncoder.draw(2, this.edgeLength);\r\n      passEncoder.setPipeline(this.nodePipeline!);\r\n      passEncoder.setVertexBuffer(0, nodePositionBuffer);\r\n      passEncoder.setBindGroup(0, this.nodeBindGroup!);\r\n      passEncoder.draw(6, this.nodeLength);\r\n      passEncoder.endPass();\r\n\r\n      device.queue.submit([commandEncoder.finish()]);\r\n\r\n      await device.queue.onSubmittedWorkDone();\r\n      // await device.queue.onSubmittedWorkDone();\r\n    };\r\n\r\n    // requestAnimationFrame(frame);\r\n  }\r\n\r\n  \r\n\r\n  async setNodeEdgeData(nodeData: Array<number>, edgeData: Array<number>) {\r\n    this.nodeDataBuffer!.destroy();\r\n    this.edgeDataBuffer!.destroy();\r\n    this.nodeDataBuffer = this.device.createBuffer({\r\n      size: nodeData.length * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\r\n    this.nodeDataBuffer.unmap();\r\n    this.edgeDataBuffer = this.device.createBuffer({\r\n      size: edgeData.length * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Uint32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n    this.edgeBindGroup = this.device.createBindGroup({\r\n      layout: this.edgePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.nodeBindGroup = this.device.createBindGroup({\r\n      layout: this.nodePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    this.edgeLength = edgeData.length;\r\n    this.nodeLength = nodeData.length / 4;\r\n    await this.testFrame!();\r\n    // this.terrainGenerator!.computeTerrain(this.nodeDataBuffer, undefined, undefined, this.rangeBuffer, this.nodeLength);\r\n  }\r\n\r\n  setWidthFactor(widthFactor: number) {\r\n    this.terrainGenerator!.computeTerrain(\r\n      undefined,\r\n      widthFactor,\r\n      undefined,\r\n      this.rangeBuffer,\r\n      this.nodeLength\r\n    );\r\n  }\r\n\r\n  setPeakValue(value: number) {\r\n    this.device.queue.writeBuffer(\r\n      this.uniform2DBuffer!,\r\n      0,\r\n      new Float32Array([value]),\r\n      0,\r\n      1\r\n    );\r\n  }\r\n\r\n  setValleyValue(value: number) {\r\n    this.device.queue.writeBuffer(\r\n      this.uniform2DBuffer!,\r\n      4,\r\n      new Float32Array([value]),\r\n      0,\r\n      1\r\n    );\r\n  }\r\n\r\n  setCoolingFactor(value: number) {\r\n    this.coolingFactor = value;\r\n  }\r\n\r\n  setIdealLength(value: number) {\r\n    this.idealLength = value;\r\n  }\r\n\r\n  setGlobalRange() {\r\n    if (this.rangeBuffer) {\r\n      this.rangeBuffer = null;\r\n    } else {\r\n      this.rangeBuffer = this.device.createBuffer({\r\n        size: 2 * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n      });\r\n    }\r\n  }\r\n\r\n  async runForceDirected() {\r\n    this.forceDirected!.runForces(\r\n      this.nodeDataBuffer!,\r\n      this.edgeDataBuffer!,\r\n      this.nodeLength,\r\n      this.edgeLength,\r\n      this.coolingFactor,\r\n      this.idealLength,\r\n      10000,\r\n      100,\r\n      this.iterRef\r\n    );\r\n  }\r\n\r\n  toggleTerrainLayer() {\r\n    this.terrainToggle = !this.terrainToggle;\r\n  }\r\n\r\n  toggleNodeLayer() {\r\n    this.nodeToggle = !this.nodeToggle;\r\n  }\r\n\r\n  toggleEdgeLayer() {\r\n    this.edgeToggle = !this.edgeToggle;\r\n  }\r\n\r\n  setColormap(colormap, colormapImage) {\r\n    this.device.queue.copyExternalImageToTexture(\r\n      { source: colormap },\r\n      { texture: this.colorTexture! },\r\n      [colormap.width, colormap.height, 1]\r\n    );\r\n    this.colormapImage = colormapImage;\r\n  }\r\n\r\n  async onSave() {\r\n    var height = this.outCanvasRef.current!.height;\r\n    var width = this.outCanvasRef.current!.width;\r\n    const gpuReadBuffer = this.device.createBuffer({\r\n      size: width * height * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n    });\r\n    console.log(width, height);\r\n    var commandEncoder = this.device.createCommandEncoder();\r\n    // Encode commands for copying buffer to buffer.\r\n    commandEncoder.copyBufferToBuffer(\r\n      this.terrainGenerator!.pixelValueBuffer /* source buffer */,\r\n      0 /* source offset */,\r\n      gpuReadBuffer /* destination buffer */,\r\n      0 /* destination offset */,\r\n      width * height * 4 /* size */\r\n    );\r\n\r\n    // Submit GPU commands.\r\n    const gpuCommands = commandEncoder.finish();\r\n    this.device.queue.submit([gpuCommands]);\r\n\r\n    // Read buffer.\r\n    await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n    const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n    var output = new Float32Array(arrayBuffer);\r\n    var context = this.outCanvasRef.current!.getContext(\"2d\");\r\n    context!.drawImage(this.colormapImage, 0, 0);\r\n    var colorData = context!.getImageData(0, 0, 180, 1).data;\r\n    var imgData = context!.createImageData(width, height);\r\n    for (var i = 0; i < height; i++) {\r\n      for (var j = 0; j < width; j++) {\r\n        var index = j + i * width;\r\n        var colorIndex =\r\n          Math.trunc(output[j + (height - 1 - i) * width] * 180) * 4;\r\n        imgData.data[index * 4] = colorData[colorIndex];\r\n        imgData.data[index * 4 + 1] = colorData[colorIndex + 1];\r\n        imgData.data[index * 4 + 2] = colorData[colorIndex + 2];\r\n        imgData.data[index * 4 + 3] = colorData[colorIndex + 3];\r\n      }\r\n    }\r\n    context!.putImageData(imgData, 0, 0);\r\n    this.outCanvasRef.current!.toBlob(function (b) {\r\n      saveAs(b!, `terrain.png`);\r\n    }, \"image/png\");\r\n  }\r\n}\r\nexport default Renderer;\r\n\r\n"]}