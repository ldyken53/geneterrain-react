{"version":3,"sources":["force_directed.ts"],"names":["wgsl_1","require","ForceDirected","device","this","coolingFactor","iterationCount","threshold","force","nodeDataBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","edgeDataBuffer","adjMatrixBuffer","laplacianBuffer","forceDataBuffer","createMatrixPipeline","createComputePipeline","compute","module","createShaderModule","code","create_adjacency_matrix","entryPoint","createQuadTreePipeline","create_quadtree","computeForcesPipeline","compute_forces","applyForcesPipeline","apply_forces","paramsBuffer","UNIFORM","positionReadBuffer","prototype","formatToD3Format","positionList","edgeList","nLength","eLength","nodeLength","length","nodeArray1","Array","edgeArray1","i","index","name","toString","x","y","sourceIndex","targetIndex","source","target","nodeArray","edgeArray","runForces","edgeLength","l","iterRef","console","log","upload","mappedAtCreation","mapping","getMappedRange","Uint32Array","set","Float32Array","unmap","adjMatrixSize","Math","ceil","commandEncoder","createCommandEncoder","copyBufferToBuffer","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","pass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","gpuReadBuffer","MAP_READ","queue","submit","finish","mapAsync","GPUMapMode","READ","_a","sent","arrayBuffer","output","Int32Array","iterationTimes","totalStart","performance","now","applyBindGroup","bindGroup","start","onSubmittedWorkDone","end","push","positionArrayBuffer","d3Format","formattednodeList","formattedEdgeList","totalEnd","iterAvg","reduce","a","b","current","innerText","exports"],"mappings":"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","file":"force_directed.min.js","sourcesContent":["import { buffer } from 'd3';\r\nimport {\r\n    apply_forces,\r\n    create_adjacency_matrix,\r\n    compute_forces,\r\n    create_quadtree\r\n} from './wgsl';\r\n\r\nimport { greadability } from \"../greadibility.js\";\r\n\r\nclass ForceDirected {\r\n  public paramsBuffer: GPUBuffer;\r\n  public nodeDataBuffer: GPUBuffer;\r\n  public edgeDataBuffer: GPUBuffer;\r\n  public adjMatrixBuffer: GPUBuffer;\r\n  public laplacianBuffer: GPUBuffer;\r\n  public forceDataBuffer: GPUBuffer;\r\n  public coolingFactor: number = 0.9;\r\n  public device: GPUDevice;\r\n  public createMatrixPipeline: GPUComputePipeline;\r\n  public createQuadTreePipeline: GPUComputePipeline;\r\n  public computeForcesPipeline: GPUComputePipeline;\r\n  public applyForcesPipeline: GPUComputePipeline;\r\n  public iterationCount: number = 10000;\r\n  public threshold: number = 100;\r\n  public force: number = 1000.0;\r\n  public positionReadBuffer: any;\r\n\r\n  constructor(device: GPUDevice) {\r\n    this.device = device;\r\n\r\n    this.nodeDataBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage:\r\n        GPUBufferUsage.STORAGE |\r\n        GPUBufferUsage.COPY_DST |\r\n        GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    this.edgeDataBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.adjMatrixBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.laplacianBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.forceDataBuffer = this.device.createBuffer({\r\n      size: 16,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    this.createMatrixPipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: create_adjacency_matrix,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    this.createQuadTreePipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: create_quadtree,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    this.computeForcesPipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: compute_forces,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    this.applyForcesPipeline = device.createComputePipeline({\r\n      compute: {\r\n        module: device.createShaderModule({\r\n          code: apply_forces,\r\n        }),\r\n        entryPoint: \"main\",\r\n      },\r\n    });\r\n\r\n    // Create a buffer to store the params, output, and min/max\r\n    this.paramsBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.positionReadBuffer = null;\r\n  }\r\n\r\n  formatToD3Format(positionList, edgeList, nLength, eLength) {\r\n    let nodeLength = positionList.length;\r\n    let nodeArray1 = new Array(nLength);\r\n    let edgeArray1 = new Array(eLength);\r\n\r\n    for (let i = 0; i < 4 * nodeLength; i = i + 4) {\r\n      nodeArray1[i / 4] = {};\r\n      nodeArray1[i / 4].index = i / 4;\r\n      nodeArray1[i / 4].name = (i / 4).toString();\r\n      nodeArray1[i / 4].x = positionList[i + 1];\r\n      nodeArray1[i / 4].y = positionList[i + 2];\r\n    }\r\n\r\n    for (let i = 0; i < eLength; i = i + 2) {\r\n      edgeArray1[i / 2] = {};\r\n      let sourceIndex = edgeList[i];\r\n      let targetIndex = edgeList[i + 1];\r\n\r\n      edgeArray1[i / 2].index = i / 2;\r\n      edgeArray1[i / 2].source = {};\r\n      edgeArray1[i / 2].source.index = sourceIndex;\r\n      edgeArray1[i / 2].source.name = sourceIndex.toString();\r\n      edgeArray1[i / 2].source.x = nodeArray1[sourceIndex].x;\r\n      edgeArray1[i / 2].source.y = nodeArray1[sourceIndex].y;\r\n\r\n      edgeArray1[i / 2].target = {};\r\n      edgeArray1[i / 2].target.index = targetIndex;\r\n      edgeArray1[i / 2].target.name = targetIndex.toString();\r\n      edgeArray1[i / 2].target.x = nodeArray1[targetIndex].x;\r\n      edgeArray1[i / 2].target.y = nodeArray1[targetIndex].y;\r\n    }\r\n\r\n    return {\r\n      nodeArray: nodeArray1,\r\n      edgeArray: edgeArray1,\r\n    };\r\n  }\r\n\r\n  async runForces(\r\n    nodeDataBuffer = this.nodeDataBuffer,\r\n    edgeDataBuffer = this.edgeDataBuffer,\r\n    nodeLength: number = 0,\r\n    edgeLength: number = 0,\r\n    coolingFactor = this.coolingFactor,\r\n    l = 0.05,\r\n    iterationCount = this.iterationCount,\r\n    threshold = this.threshold,\r\n    iterRef,\r\n    edgeList\r\n  ) {\r\n    if (nodeLength == 0 || edgeLength == 0) {\r\n      return;\r\n    }\r\n    console.log(l);\r\n    console.log(coolingFactor);\r\n    this.coolingFactor = coolingFactor;\r\n    this.nodeDataBuffer = nodeDataBuffer;\r\n    this.edgeDataBuffer = edgeDataBuffer;\r\n    this.threshold = threshold;\r\n    this.force = 100000;\r\n\r\n    // Set up params (node length, edge length) for creating adjacency matrix\r\n    var upload = this.device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.COPY_SRC,\r\n      mappedAtCreation: true,\r\n    });\r\n    var mapping = upload.getMappedRange();\r\n    new Uint32Array(mapping).set([nodeLength, edgeLength]);\r\n    new Float32Array(mapping).set([this.coolingFactor, l], 2);\r\n    upload.unmap();\r\n    let adjMatrixSize = Math.ceil((nodeLength * nodeLength * 4) / 32);\r\n    this.adjMatrixBuffer = this.device.createBuffer({\r\n      size: adjMatrixSize,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    this.laplacianBuffer = this.device.createBuffer({\r\n      size: nodeLength * nodeLength * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    var commandEncoder = this.device.createCommandEncoder();\r\n    commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 4 * 4);\r\n    var createBindGroup = this.device.createBindGroup({\r\n      layout: this.createMatrixPipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.adjMatrixBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.paramsBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 3,\r\n          resource: {\r\n            buffer: this.laplacianBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n\r\n    var pass = commandEncoder.beginComputePass();\r\n    pass.setBindGroup(0, createBindGroup);\r\n    pass.setPipeline(this.createMatrixPipeline);\r\n    pass.dispatch(1, 1, 1);\r\n    pass.endPass();\r\n    // Log adjacency matrix\r\n    const gpuReadBuffer = this.device.createBuffer({\r\n      size: nodeLength * nodeLength * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n    });\r\n    // Encode commands for copying buffer to buffer.\r\n    commandEncoder.copyBufferToBuffer(\r\n      this.adjMatrixBuffer /* source buffer */,\r\n      0 /* source offset */,\r\n      gpuReadBuffer /* destination buffer */,\r\n      0 /* destination offset */,\r\n      adjMatrixSize /* size */\r\n    );\r\n    this.device.queue.submit([commandEncoder.finish()]);\r\n\r\n    // Log adjacency matrix (count should be equal to the number of nonduplicate edges)\r\n    await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n    const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n    var output = new Int32Array(arrayBuffer);\r\n    var count = 0;\r\n    // for (var i = 0; i < output.length; i++) {\r\n    //     count+=output[i];\r\n    // }\r\n    console.log(output);\r\n    console.log(count);\r\n    console.log(output.length);\r\n\r\n    this.forceDataBuffer = this.device.createBuffer({\r\n      size: nodeLength * 2 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n\r\n    var iterationTimes: Array<number> = [];\r\n    var totalStart = performance.now();\r\n    var applyBindGroup = this.device.createBindGroup({\r\n      layout: this.applyForcesPipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.forceDataBuffer,\r\n          },\r\n        },\r\n      ],\r\n    });\r\n    while (\r\n      iterationCount > 0 &&\r\n      this.coolingFactor > 0.0001 &&\r\n      this.force >= 0\r\n    ) {\r\n      iterationCount--;\r\n      // Set up params (node length, edge length)\r\n      var upload = this.device.createBuffer({\r\n        size: 4 * 4,\r\n        usage: GPUBufferUsage.COPY_SRC,\r\n        mappedAtCreation: true,\r\n      });\r\n      var mapping = upload.getMappedRange();\r\n      new Uint32Array(mapping).set([nodeLength, edgeLength]);\r\n      new Float32Array(mapping).set([this.coolingFactor, l], 2);\r\n      upload.unmap();\r\n      //this.device.createQuerySet({})\r\n      var commandEncoder = this.device.createCommandEncoder();\r\n      //commandEncoder.writeTimestamp();\r\n      commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 4 * 4);\r\n      // Create bind group\r\n      var bindGroup = this.device.createBindGroup({\r\n        layout: this.computeForcesPipeline.getBindGroupLayout(0),\r\n        entries: [\r\n          {\r\n            binding: 0,\r\n            resource: {\r\n              buffer: this.nodeDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 1,\r\n            resource: {\r\n              buffer: this.adjMatrixBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 2,\r\n            resource: {\r\n              buffer: this.forceDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 3,\r\n            resource: {\r\n              buffer: this.paramsBuffer,\r\n            },\r\n          },\r\n        ],\r\n      });\r\n\r\n      // Run attract forces pass\r\n      // var pass = commandEncoder.beginComputePass();\r\n      // pass.setBindGroup(0, attractBindGroup);\r\n      // pass.setPipeline(this.computeAttractForcesPipeline);\r\n      // pass.dispatch(1, 1, 1);\r\n      // pass.endPass();\r\n      // this.device.queue.submit([commandEncoder.finish()]);\r\n      // var start : number = performance.now();\r\n      // await this.device.queue.onSubmittedWorkDone();\r\n      // var end : number = performance.now();\r\n      // console.log(`attract force time: ${end - start}`)\r\n      // var commandEncoder = this.device.createCommandEncoder();\r\n\r\n      // Run compute forces pass\r\n      var pass = commandEncoder.beginComputePass();\r\n      pass.setBindGroup(0, bindGroup);\r\n      pass.setPipeline(this.computeForcesPipeline);\r\n      pass.dispatch(nodeLength, 1, 1);\r\n      pass.endPass();\r\n\r\n      // Testing timing of both passes (comment out when not debugging)\r\n      // pass.endPass();\r\n      // this.device.queue.submit([commandEncoder.finish()]);\r\n      // var start : number = performance.now();\r\n      // await this.device.queue.onSubmittedWorkDone();\r\n      // var end : number = performance.now();\r\n      // console.log(`compute force time: ${end - start}`)\r\n      // var commandEncoder = this.device.createCommandEncoder();\r\n\r\n      // const gpuReadBuffer = this.device.createBuffer({\r\n      //     size: nodeLength * 2 * 4,\r\n      //     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n      // });\r\n      // // Encode commands for copying buffer to buffer.\r\n      // commandEncoder.copyBufferToBuffer(\r\n      //     this.forceDataBuffer /* source buffer */ ,\r\n      //     0 /* source offset */ ,\r\n      //     gpuReadBuffer /* destination buffer */ ,\r\n      //     0 /* destination offset */ ,\r\n      //     nodeLength * 2 * 4 /* size */\r\n      // );\r\n      var pass = commandEncoder.beginComputePass();\r\n\r\n      //commandEncoder.writeTimestamp();\r\n\r\n      // Run apply forces pass\r\n      pass.setBindGroup(0, applyBindGroup);\r\n      pass.setPipeline(this.applyForcesPipeline);\r\n      pass.dispatch(nodeLength, 1, 1);\r\n      pass.endPass();\r\n\r\n      this.positionReadBuffer = this.device.createBuffer({\r\n        size: nodeLength * 4 * 4,\r\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n      });\r\n\r\n      commandEncoder.copyBufferToBuffer(\r\n        this.nodeDataBuffer,\r\n        0,\r\n        this.positionReadBuffer,\r\n        0,\r\n        nodeLength * 4 * 4\r\n      );\r\n\r\n      await this.device.queue.submit([commandEncoder.finish()]);\r\n\r\n      var start: number = performance.now();\r\n      await this.device.queue.onSubmittedWorkDone();\r\n      var end: number = performance.now();\r\n      console.log(`iteration time ${end - start}`);\r\n      iterationTimes.push(end - start);\r\n\r\n      // this.maxForceResultBuffer.unmap();\r\n      // Read all of the forces applied.\r\n      // await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n      // const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n      // var output = new Float32Array(arrayBuffer);\r\n      // console.log(output);\r\n      this.coolingFactor = this.coolingFactor * coolingFactor;\r\n    }\r\n\r\n    await this.positionReadBuffer.mapAsync(GPUMapMode.READ);\r\n    let positionArrayBuffer = this.positionReadBuffer.getMappedRange();\r\n    let positionList = new Float32Array(positionArrayBuffer);\r\n\r\n    let d3Format = this.formatToD3Format(\r\n      positionList,\r\n      edgeList,\r\n      nodeLength,\r\n      edgeLength\r\n    );\r\n    let formattednodeList = d3Format.nodeArray;\r\n    let formattedEdgeList = d3Format.edgeArray;\r\n\r\n    console.log(formattednodeList, formattedEdgeList);\r\n    // console.log(greadability(formattednodeList, formattedEdgeList));\r\n\r\n    var totalEnd = performance.now();\r\n    var iterAvg: number =\r\n      iterationTimes.reduce(function (a, b) {\r\n        return a + b;\r\n      }) / iterationTimes.length;\r\n    iterRef.current!.innerText = `Completed in ${\r\n      iterationTimes.length\r\n    } iterations with total time ${\r\n      totalEnd - totalStart\r\n    } and average iteration time ${iterAvg}`;\r\n  }\r\n}\r\n\r\nexport default ForceDirected;"]}