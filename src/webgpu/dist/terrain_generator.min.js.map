{"version":3,"sources":["terrain_generator.ts"],"names":["wgsl_1","require","TerrainGenerator","device","width","height","this","nodeDataBuffer","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","rangeBuffer","COPY_SRC","storage","uniform","computeTerrainBGLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","computeTerrainPipeline","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","compute_terrain","entryPoint","normalizeTerrainBGLayout","normalizeTerrainPipeline","normalize_terrain","paramsBuffer","UNIFORM","pixelValueBuffer","prototype","computeTerrain","widthFactor","translation","globalRange","nodeLength","upload","mappedAtCreation","mapping","getMappedRange","Uint32Array","set","Float32Array","unmap","commandEncoder","createCommandEncoder","copyBufferToBuffer","bindGroup","createBindGroup","resource","pass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","exports"],"mappings":"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","file":"terrain_generator.min.js","sourcesContent":["import { compute_terrain, normalize_terrain } from './wgsl';\r\n\r\nclass TerrainGenerator {\r\n    public rangeBuffer : GPUBuffer;\r\n    public pixelValueBuffer : GPUBuffer;\r\n    public paramsBuffer : GPUBuffer;\r\n    public nodeDataBuffer : GPUBuffer;\r\n    public device : GPUDevice;\r\n    public width : number;\r\n    public height : number;\r\n    public computeTerrainPipeline : GPUComputePipeline;\r\n    public normalizeTerrainPipeline : GPUComputePipeline;\r\n    public computeTerrainBGLayout : GPUBindGroupLayout;\r\n    public normalizeTerrainBGLayout : GPUBindGroupLayout;\r\n    \r\n    constructor(device : GPUDevice, width, height) {\r\n        this.device = device;\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.nodeDataBuffer = this.device.createBuffer({\r\n            size: 16,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        });\r\n        this.rangeBuffer = this.device.createBuffer({\r\n            size: 2 * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n\r\n        var storage : GPUBufferBindingType = \"storage\";\r\n        var uniform : GPUBufferBindingType = \"uniform\";\r\n        this.computeTerrainBGLayout = device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: storage,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: uniform,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: storage,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: storage,\r\n                    }\r\n                }\r\n            ],\r\n        });\r\n\r\n        this.computeTerrainPipeline = device.createComputePipeline({\r\n            layout: device.createPipelineLayout({\r\n                bindGroupLayouts: [this.computeTerrainBGLayout],\r\n            }),\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: compute_terrain,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        this.normalizeTerrainBGLayout = device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: storage,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: uniform,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: storage,\r\n                    }\r\n                }\r\n            ],\r\n        });\r\n\r\n        this.normalizeTerrainPipeline = device.createComputePipeline({\r\n            layout: device.createPipelineLayout({\r\n                bindGroupLayouts: [this.normalizeTerrainBGLayout],\r\n            }),\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: normalize_terrain,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        // Create a buffer to store the params, output, and min/max\r\n        this.paramsBuffer = device.createBuffer({\r\n            size: 8 * 4,\r\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n        });\r\n\r\n        this.pixelValueBuffer = device.createBuffer({\r\n            size: this.width * this.height * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n    }\r\n\r\n    computeTerrain(nodeDataBuffer = this.nodeDataBuffer, widthFactor = 1000, translation = [0, 0, 1, 1], globalRange : null | GPUBuffer = null, nodeLength : number = 0) {\r\n      if (nodeLength == 0) {\r\n        return;\r\n      }\r\n      this.nodeDataBuffer = nodeDataBuffer;\r\n\r\n      // Have to reset range buffer unless global range checked\r\n      if (!globalRange) {\r\n        this.rangeBuffer = this.device.createBuffer({\r\n          size: 2 * 4,\r\n          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n      } else {\r\n        this.rangeBuffer = globalRange;\r\n      }\r\n\r\n      // Set up params (image width, height, node length, and width factor)\r\n      var upload = this.device.createBuffer({\r\n        size: 8 * 4,\r\n        usage: GPUBufferUsage.COPY_SRC,\r\n        mappedAtCreation: true,\r\n      });\r\n\r\n      var mapping = upload.getMappedRange();\r\n      new Uint32Array(mapping).set([this.width, this.height, nodeLength]);\r\n      new Float32Array(mapping).set(\r\n        [\r\n          widthFactor,\r\n          translation[0],\r\n          translation[1],\r\n          translation[2],\r\n          translation[3],\r\n        ],\r\n        3\r\n      );\r\n      upload.unmap();\r\n      //this.device.createQuerySet({})\r\n      var commandEncoder = this.device.createCommandEncoder();\r\n      //commandEncoder.writeTimestamp();\r\n      commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 8 * 4);\r\n      // Create bind group\r\n      var bindGroup = this.device.createBindGroup({\r\n        layout: this.computeTerrainBGLayout,\r\n        entries: [\r\n          {\r\n            binding: 0,\r\n            resource: {\r\n              buffer: this.nodeDataBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 1,\r\n            resource: {\r\n              buffer: this.paramsBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 2,\r\n            resource: {\r\n              buffer: this.pixelValueBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 3,\r\n            resource: {\r\n              buffer: this.rangeBuffer,\r\n            },\r\n          },\r\n        ],\r\n      });\r\n\r\n      // Run compute terrain pass\r\n      var pass = commandEncoder.beginComputePass();\r\n      pass.setBindGroup(0, bindGroup);\r\n      pass.setPipeline(this.computeTerrainPipeline);\r\n      pass.dispatch(this.width, this.height, 1);\r\n      //commandEncoder.writeTimestamp();\r\n      // await this.device.queue.onSubmittedWorkDone();\r\n\r\n      // Look into submitting normalization and compute in one pass to improve speed, remove synchronizations\r\n      // Use writetimestamp for more accurate kernel timing\r\n\r\n      // Run normalize terrain pass\r\n      var bindGroup = this.device.createBindGroup({\r\n        layout: this.normalizeTerrainBGLayout,\r\n        entries: [\r\n          {\r\n            binding: 0,\r\n            resource: {\r\n              buffer: this.pixelValueBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 1,\r\n            resource: {\r\n              buffer: this.paramsBuffer,\r\n            },\r\n          },\r\n          {\r\n            binding: 2,\r\n            resource: {\r\n              buffer: this.rangeBuffer,\r\n            },\r\n          },\r\n        ],\r\n      });\r\n      pass.setBindGroup(0, bindGroup);\r\n      pass.setPipeline(this.normalizeTerrainPipeline);\r\n      pass.dispatch(this.width, this.height, 1);\r\n      pass.endPass();\r\n      this.device.queue.submit([commandEncoder.finish()]);\r\n      // await this.device.queue.onSubmittedWorkDone();\r\n    }\r\n}\r\n\r\nexport default TerrainGenerator;"]}