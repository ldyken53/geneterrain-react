{"version":3,"sources":["greadibility.js"],"names":["greadability","nodes","links","id","getSumOfArray","numArray","i","graphStats","length","crossing","n","sum","crossingAngle","m","cMax","dMax","degree","Array","angularResolutionMin","angularResolutionDev","pk","p1","pi","source","index","splice","pj","p2","onSegment","link","min","max","push","target","linksCross","link1","link2","line1","line2","d1","direction","d4","d2","d3","Math","linesCross","y","linkCrossings","x","linesegmentsAngle","len","temp","angle2","sLine1","sLine2","hypot","angle1","acuteLinesAngle","acos","PI","slope1","slope2","angle","angularRes","resMin","node","incident","line0","nextLink","b","angleB","nodeById","filter","l","d","initialize","_typeof","filteredLinks","forEach","s","t","sort","a","map","crossInfo","j","c","abs","idealAngle","angularResInfo","incidentLinkAngles","nonZeroDeg","minAngle","resDev","angleA","apply","idealMinAngle"],"mappings":"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","file":"greadibility.min.js","sourcesContent":["export let greadability = function (nodes, links, id) {\r\n  var i,\r\n    j,\r\n    n = nodes.length,\r\n    m,\r\n    degree = new Array(nodes.length),\r\n    cMax,\r\n    idealAngle = 70,\r\n    dMax;\r\n\r\n  /*\r\n   * Tracks the global graph readability metrics.\r\n   */\r\n  var graphStats = {\r\n    crossing: 0, // Normalized link crossings\r\n    crossingAngle: 0, // Normalized average dev from 70 deg\r\n    angularResolutionMin: 0, // Normalized avg dev from ideal min angle\r\n    angularResolutionDev: 0, // Normalized avg dev from each link\r\n  };\r\n\r\n  var getSumOfArray = function (numArray) {\r\n    var i = 0,\r\n      n = numArray.length,\r\n      sum = 0;\r\n    for (; i < n; ++i) sum += numArray[i];\r\n    return sum;\r\n  };\r\n\r\n  var initialize = function () {\r\n    var i, j, link;\r\n    var nodeById = {};\r\n    // Filter out self loops\r\n    links = links.filter(function (l) {\r\n      return l.source !== l.target;\r\n    });\r\n\r\n    m = links.length;\r\n\r\n    if (!id) {\r\n      id = function (d) {\r\n        return d.index;\r\n      };\r\n    }\r\n\r\n    for (i = 0; i < n; ++i) {\r\n      nodes[i].index = i;\r\n      degree[i] = [];\r\n      nodeById[id(nodes[i], i, nodeById)] = nodes[i];\r\n    }\r\n\r\n    // Make sure source and target are nodes and not indices.\r\n    for (i = 0; i < m; ++i) {\r\n      link = links[i];\r\n      if (typeof link.source !== \"object\") link.source = nodeById[link.source];\r\n      if (typeof link.target !== \"object\") link.target = nodeById[link.target];\r\n    }\r\n\r\n    // Filter out duplicate links\r\n    var filteredLinks = [];\r\n    links.forEach(function (l) {\r\n      var s = l.source,\r\n        t = l.target;\r\n      if (s.index > t.index) {\r\n        filteredLinks.push({ source: t, target: s });\r\n      } else {\r\n        filteredLinks.push({ source: s, target: t });\r\n      }\r\n    });\r\n    links = filteredLinks;\r\n    links.sort(function (a, b) {\r\n      if (a.source.index < b.source.index) return -1;\r\n      if (a.source.index > b.source.index) return 1;\r\n      if (a.target.index < b.target.index) return -1;\r\n      if (a.target.index > b.target.index) return 1;\r\n      return 0;\r\n    });\r\n    i = 1;\r\n    while (i < links.length) {\r\n      if (\r\n        links[i - 1].source.index === links[i].source.index &&\r\n        links[i - 1].target.index === links[i].target.index\r\n      ) {\r\n        links.splice(i, 1);\r\n      } else ++i;\r\n    }\r\n\r\n    // Update length, if a duplicate was deleted.\r\n    m = links.length;\r\n\r\n    // Calculate degree.\r\n    for (i = 0; i < m; ++i) {\r\n      link = links[i];\r\n      link.index = i;\r\n\r\n      degree[link.source.index].push(link);\r\n      degree[link.target.index].push(link);\r\n    }\r\n  };\r\n\r\n  // Assume node.x and node.y are the coordinates\r\n\r\n  function direction(pi, pj, pk) {\r\n    var p1 = [pk[0] - pi[0], pk[1] - pi[1]];\r\n    var p2 = [pj[0] - pi[0], pj[1] - pi[1]];\r\n    return p1[0] * p2[1] - p2[0] * p1[1];\r\n  }\r\n\r\n  // Is point k on the line segment formed by points i and j?\r\n  // Inclusive, so if pk == pi or pk == pj then return true.\r\n  function onSegment(pi, pj, pk) {\r\n    return (\r\n      Math.min(pi[0], pj[0]) <= pk[0] &&\r\n      pk[0] <= Math.max(pi[0], pj[0]) &&\r\n      Math.min(pi[1], pj[1]) <= pk[1] &&\r\n      pk[1] <= Math.max(pi[1], pj[1])\r\n    );\r\n  }\r\n\r\n  function linesCross(line1, line2) {\r\n    var d1, d2, d3, d4;\r\n\r\n    // CLRS 2nd ed. pg. 937\r\n    d1 = direction(line2[0], line2[1], line1[0]);\r\n    d2 = direction(line2[0], line2[1], line1[1]);\r\n    d3 = direction(line1[0], line1[1], line2[0]);\r\n    d4 = direction(line1[0], line1[1], line2[1]);\r\n\r\n    if (\r\n      ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\r\n      ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))\r\n    ) {\r\n      return true;\r\n    } else if (d1 === 0 && onSegment(line2[0], line2[1], line1[0])) {\r\n      return true;\r\n    } else if (d2 === 0 && onSegment(line2[0], line2[1], line1[1])) {\r\n      return true;\r\n    } else if (d3 === 0 && onSegment(line1[0], line1[1], line2[0])) {\r\n      return true;\r\n    } else if (d4 === 0 && onSegment(line1[0], line1[1], line2[1])) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function linksCross(link1, link2) {\r\n    // Self loops are not intersections\r\n    if (\r\n      link1.index === link2.index ||\r\n      link1.source === link1.target ||\r\n      link2.source === link2.target\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    // Links cannot intersect if they share a node\r\n    if (\r\n      link1.source === link2.source ||\r\n      link1.source === link2.target ||\r\n      link1.target === link2.source ||\r\n      link1.target === link2.target\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    var line1 = [\r\n      [link1.source.x, link1.source.y],\r\n      [link1.target.x, link1.target.y],\r\n    ];\r\n\r\n    var line2 = [\r\n      [link2.source.x, link2.source.y],\r\n      [link2.target.x, link2.target.y],\r\n    ];\r\n\r\n    return linesCross(line1, line2);\r\n  }\r\n\r\n  function linkCrossings() {\r\n    var i,\r\n      j,\r\n      c = 0,\r\n      d = 0,\r\n      link1,\r\n      link2,\r\n      line1,\r\n      line2;\r\n\r\n    // Sum the upper diagonal of the edge crossing matrix.\r\n    for (i = 0; i < m; ++i) {\r\n      for (j = i + 1; j < m; ++j) {\r\n        link1 = links[i];\r\n        link2 = links[j];\r\n\r\n        // Check if link i and link j intersect\r\n        if (linksCross(link1, link2)) {\r\n          line1 = [\r\n            [link1.source.x, link1.source.y],\r\n            [link1.target.x, link1.target.y],\r\n          ];\r\n          line2 = [\r\n            [link2.source.x, link2.source.y],\r\n            [link2.target.x, link2.target.y],\r\n          ];\r\n          ++c;\r\n          d += Math.abs(idealAngle - acuteLinesAngle(line1, line2));\r\n        }\r\n      }\r\n    }\r\n\r\n    return { c: 2 * c, d: 2 * d };\r\n  }\r\n\r\n  function linesegmentsAngle(line1, line2) {\r\n    // Finds the (counterclockwise) angle from line segement line1 to\r\n    // line segment line2. Assumes the lines share one end point.\r\n    // If both endpoints are the same, or if both lines have zero\r\n    // length, then return 0 angle.\r\n    // Param order matters:\r\n    // linesegmentsAngle(line1, line2) != linesegmentsAngle(line2, line1)\r\n    var temp, len, angle1, angle2, sLine1, sLine2;\r\n\r\n    // Re-orient so that line1[0] and line2[0] are the same.\r\n    if (line1[0][0] === line2[1][0] && line1[0][1] === line2[1][1]) {\r\n      temp = line2[1];\r\n      line2[1] = line2[0];\r\n      line2[0] = temp;\r\n    } else if (line1[1][0] === line2[0][0] && line1[1][1] === line2[0][1]) {\r\n      temp = line1[1];\r\n      line1[1] = line1[0];\r\n      line1[0] = temp;\r\n    } else if (line1[1][0] === line2[1][0] && line1[1][1] === line2[1][1]) {\r\n      temp = line1[1];\r\n      line1[1] = line1[0];\r\n      line1[0] = temp;\r\n      temp = line2[1];\r\n      line2[1] = line2[0];\r\n      line2[0] = temp;\r\n    }\r\n\r\n    // Shift the line so that the first point is at (0,0).\r\n    sLine1 = [\r\n      [line1[0][0] - line1[0][0], line1[0][1] - line1[0][1]],\r\n      [line1[1][0] - line1[0][0], line1[1][1] - line1[0][1]],\r\n    ];\r\n    // Normalize the line length.\r\n    len = Math.hypot(sLine1[1][0], sLine1[1][1]);\r\n    if (len === 0) return 0;\r\n    sLine1[1][0] /= len;\r\n    sLine1[1][1] /= len;\r\n    // If y < 0, angle = acos(x), otherwise angle = 360 - acos(x)\r\n    angle1 = (Math.acos(sLine1[1][0]) * 180) / Math.PI;\r\n    if (sLine1[1][1] < 0) angle1 = 360 - angle1;\r\n\r\n    // Shift the line so that the first point is at (0,0).\r\n    sLine2 = [\r\n      [line2[0][0] - line2[0][0], line2[0][1] - line2[0][1]],\r\n      [line2[1][0] - line2[0][0], line2[1][1] - line2[0][1]],\r\n    ];\r\n    // Normalize the line length.\r\n    len = Math.hypot(sLine2[1][0], sLine2[1][1]);\r\n    if (len === 0) return 0;\r\n    sLine2[1][0] /= len;\r\n    sLine2[1][1] /= len;\r\n    // If y < 0, angle = acos(x), otherwise angle = 360 - acos(x)\r\n    angle2 = (Math.acos(sLine2[1][0]) * 180) / Math.PI;\r\n    if (sLine2[1][1] < 0) angle2 = 360 - angle2;\r\n\r\n    return angle1 <= angle2 ? angle2 - angle1 : 360 - (angle1 - angle2);\r\n  }\r\n\r\n  function acuteLinesAngle(line1, line2) {\r\n    // Acute angle of intersection, in degrees. Assumes these lines\r\n    // intersect.\r\n    var slope1 = (line1[1][1] - line1[0][1]) / (line1[1][0] - line1[0][0]);\r\n    var slope2 = (line2[1][1] - line2[0][1]) / (line2[1][0] - line2[0][0]);\r\n\r\n    // If these lines are two links incident on the same node, need\r\n    // to check if the angle is 0 or 180.\r\n    if (slope1 === slope2) {\r\n      // If line2 is not on line1 and line1 is not on line2, then\r\n      // the lines share only one point and the angle must be 180.\r\n      if (\r\n        !(\r\n          onSegment(line1[0], line1[1], line2[0]) &&\r\n          onSegment(line1[0], line1[1], line2[1])\r\n        ) ||\r\n        !(\r\n          onSegment(line2[0], line2[1], line1[0]) &&\r\n          onSegment(line2[0], line2[1], line1[1])\r\n        )\r\n      )\r\n        return 180;\r\n      else return 0;\r\n    }\r\n\r\n    var angle = Math.abs(Math.atan(slope1) - Math.atan(slope2));\r\n\r\n    return ((angle > Math.PI / 2 ? Math.PI - angle : angle) * 180) / Math.PI;\r\n  }\r\n\r\n  function angularRes() {\r\n    var j,\r\n      resMin = 0,\r\n      resDev = 0,\r\n      nonZeroDeg,\r\n      node,\r\n      minAngle,\r\n      idealMinAngle,\r\n      incident,\r\n      line0,\r\n      line1,\r\n      line2,\r\n      incidentLinkAngles,\r\n      nextLink;\r\n\r\n    nonZeroDeg = degree.filter(function (d) {\r\n      return d.length >= 1;\r\n    }).length;\r\n\r\n    for (j = 0; j < n; ++j) {\r\n      node = nodes[j];\r\n      line0 = [\r\n        [node.x, node.y],\r\n        [node.x + 1, node.y],\r\n      ];\r\n\r\n      // Links that are incident to this node (already filtered out self loops)\r\n      incident = degree[j];\r\n\r\n      if (incident.length <= 1) continue;\r\n\r\n      idealMinAngle = 360 / incident.length;\r\n\r\n      // Sort edges by the angle they make from an imaginary vector\r\n      // emerging at angle 0 on the unit circle.\r\n      // Necessary for calculating angles of incident edges correctly\r\n      incident.sort(function (a, b) {\r\n        line1 = [\r\n          [a.source.x, a.source.y],\r\n          [a.target.x, a.target.y],\r\n        ];\r\n        line2 = [\r\n          [b.source.x, b.source.y],\r\n          [b.target.x, b.target.y],\r\n        ];\r\n        var angleA = linesegmentsAngle(line0, line1);\r\n        var angleB = linesegmentsAngle(line0, line2);\r\n        return angleA < angleB ? -1 : angleA > angleB ? 1 : 0;\r\n      });\r\n\r\n      incidentLinkAngles = incident.map(function (l, i) {\r\n        nextLink = incident[(i + 1) % incident.length];\r\n        line1 = [\r\n          [l.source.x, l.source.y],\r\n          [l.target.x, l.target.y],\r\n        ];\r\n        line2 = [\r\n          [nextLink.source.x, nextLink.source.y],\r\n          [nextLink.target.x, nextLink.target.y],\r\n        ];\r\n        return linesegmentsAngle(line1, line2);\r\n      });\r\n\r\n      minAngle = Math.min.apply(null, incidentLinkAngles);\r\n\r\n      resMin += Math.abs(idealMinAngle - minAngle) / idealMinAngle;\r\n\r\n      resDev +=\r\n        getSumOfArray(\r\n          incidentLinkAngles.map(function (angle) {\r\n            return Math.abs(idealMinAngle - angle) / idealMinAngle;\r\n          })\r\n        ) /\r\n        (2 * incident.length - 2);\r\n    }\r\n\r\n    // Divide by number of nodes with degree != 0\r\n    resMin = resMin / nonZeroDeg;\r\n\r\n    // Divide by number of nodes with degree != 0\r\n    resDev = resDev / nonZeroDeg;\r\n\r\n    return { resMin: resMin, resDev: resDev };\r\n  }\r\n\r\n  initialize();\r\n\r\n  cMax =\r\n    (m * (m - 1)) / 2 -\r\n    getSumOfArray(\r\n      degree.map(function (d) {\r\n        return d.length * (d.length - 1);\r\n      })\r\n    ) /\r\n      2;\r\n\r\n  var crossInfo = linkCrossings();\r\n\r\n  dMax = crossInfo.c * idealAngle;\r\n\r\n  graphStats.crossing = 1 - (cMax > 0 ? crossInfo.c / cMax : 0);\r\n\r\n  graphStats.crossingAngle = 1 - (dMax > 0 ? crossInfo.d / dMax : 0);\r\n\r\n  var angularResInfo = angularRes();\r\n\r\n  graphStats.angularResolutionMin = 1 - angularResInfo.resMin;\r\n\r\n  graphStats.angularResolutionDev = 1 - angularResInfo.resDev;\r\n\r\n  return graphStats;\r\n};\r\n"]}