{"version":3,"sources":["components/Sidebar.tsx","webgpu/ez_canvas_controller.ts","webgpu/terrain_generator.ts","webgpu/wgsl.tsx","webgpu/render.tsx","components/Page.tsx","components/rainbow.png","App.tsx","index.tsx"],"names":["Sidebar","props","state","nodeData","handleSubmit","bind","readFiles","event","preventDefault","this","setNodeData","files","target","console","log","nodeIDToValue","edgeReader","FileReader","onload","layoutReader","layoutData","result","split","parts","push","parseFloat","setState","readAsText","nodeReader","rawNodes","element","className","Form","style","color","onSubmit","Group","controlId","Label","Control","type","multiple","onChange","Button","variant","value","trigger","defaultValue","min","max","e","setWidthFactor","step","setPeakValue","setValleyValue","Check","defaultChecked","onClick","setGlobalRange","label","toggleTerrainLayer","toggleNodeLayer","React","Component","Controller","mousemove","press","wheel","canvas","prevMouse","self","addEventListener","evt","rect","getBoundingClientRect","curMouse","clientX","left","clientY","top","deltaY","oncontextmenu","TerrainGenerator","device","width","height","rangeBuffer","pixelValueBuffer","paramsBuffer","nodeDataBuffer","computeTerrainPipeline","normalizeTerrainPipeline","computeTerrainBGLayout","normalizeTerrainBGLayout","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","storage","uniform","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","UNIFORM","widthFactor","translation","globalRange","length","mappedAtCreation","Float32Array","getMappedRange","set","unmap","upload","mapping","Uint32Array","commandEncoder","createCommandEncoder","copyBufferToBuffer","bindGroup","createBindGroup","resource","pass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","Renderer","adapter","canvasRef","colormap","uniform2DBuffer","terrainGenerator","bindGroup2D","nodeBindGroup","nodePositionBuffer","nodePipeline","nodeLength","nodeToggle","terrainToggle","current","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","configure","format","VERTEX","createRenderPipeline","vertex","buffers","arrayStride","attributes","offset","shaderLocation","fragment","targets","primitive","topology","multisample","count","pipeline","dataBuf2D","writeBuffer","imageSizeBuffer","colorTexture","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","getBindGroupLayout","createView","viewBoxBuffer","newTranslation","controller","render","prev","cur","buttons","change","Math","abs","computeTerrain","undefined","amt","registerForCanvas","viewBoxBindGroup","view","sampleCount","requestAnimationFrame","frame","renderPassDescriptor","colorAttachments","resolveTarget","getCurrentTexture","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setVertexBuffer","draw","nodePositions","radius","i","x","y","Page","createRef","renderer","navigator","gpu","requestAdapter","requestDevice","colormapImage","Image","src","decode","createImageBitmap","imageBitmap","ref","App","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.22602008.chunk.js","sourcesContent":["import React from 'react';\nimport {Form, Button} from \"react-bootstrap\";\nimport Collapsible from 'react-collapsible';\n\ntype SidebarProps = {\n  setNodeData: (nodeData : Array<number>) => void,\n  setWidthFactor: (widthFactor : number) => void,\n  setPeakValue: (value : number) => void,\n  setValleyValue: (value : number) => void,\n  setGlobalRange: () => void,\n  toggleNodeLayer: () => void,\n  toggleTerrainLayer: () => void,\n}\ntype SidebarState = {\n  nodeData: Array<number>\n}\nclass Sidebar extends React.Component<SidebarProps, SidebarState> {\n    constructor(props) {\n      super(props);\n      this.state = {nodeData: []};\n  \n      this.handleSubmit = this.handleSubmit.bind(this);\n      this.readFiles = this.readFiles.bind(this);\n    }\n  \n    handleSubmit(event) {\n      event.preventDefault();\n      this.props.setNodeData(this.state.nodeData);\n    }\n\n    readFiles(event : React.ChangeEvent<HTMLInputElement>) {\n        const files : FileList = event.target.files!;\n        console.log(files);\n        var nodeIDToValue = {};\n        var nodeData : Array<number> = [];\n        const edgeReader = new FileReader();\n        edgeReader.onload = (event) => {\n        //   var edgeData = (edgeReader.result as string).split(\"\\n\");\n        //   for (var element of edgeData) {\n        //     var parts = element.split(\"\\t\");\n        //     if (nodeIDToValue[parts[0]] && nodeIDToValue[parts[1]]) {\n        //       nodeElements.push({ data: { source: parts[0], target: parts[1], weight: parseFloat(parts[2]) } });\n        //     }\n        //   }\n        //   await render(nodeData, index);\n            console.log(\"not yet implemented edges\");\n        };\n        const layoutReader = new FileReader();\n        layoutReader.onload = (event) => {\n          var layoutData = (layoutReader.result as string).split(\"\\n\");\n          for (var element of layoutData) {\n            var parts = element.split(\"\\t\");\n            if (nodeIDToValue[parts[0]]) {\n              // Pushes values to node data in order of struct for WebGPU:\n              // nodeValue, nodeX, nodeY, nodeSize\n              nodeData.push(parseFloat(nodeIDToValue[parts[0]]), parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));\n            }\n          }\n          this.setState({nodeData: nodeData});\n          edgeReader.readAsText(files[1]);\n        };\n        const nodeReader = new FileReader();\n        nodeReader.onload = (event) => {\n          var rawNodes = (nodeReader.result as string).split(\"\\n\");\n          for (var element of rawNodes) {\n            nodeIDToValue[element.split(\"\\t\")[0]] = element.split(\"\\t\")[1]\n          }\n          layoutReader.readAsText(files[1]);\n        };\n        nodeReader.readAsText(files[0]);\n    }\n  \n    render() {\n      return (\n        <div className=\"sidebar\"> \n        <Form style={{color: 'white'}} onSubmit={this.handleSubmit}>\n          <Form.Group controlId=\"formFile\" className=\"mt-3 mb-3\">\n            <Form.Label>Select Example Files</Form.Label>\n            <Form.Control className=\"form-control\" type=\"file\" multiple onChange={this.readFiles}/>\n            <Button className=\"mt-2\" type=\"submit\" variant=\"secondary\" value=\"Submit\">Submit</ Button>\n          </Form.Group>\n          <Collapsible trigger=\"Terrain Options\">\n            <Form.Group> \n              <Form.Label> Width Factor </ Form.Label>\n              <br/>\n              <input type=\"range\" defaultValue={1000} min={0} max={2000} onChange={(e) => this.props.setWidthFactor(parseFloat(e.target.value))} />\n            </Form.Group>\n            <Form.Group> \n              <Form.Label> Peak and Valley Values </ Form.Label>\n              <br/>\n              <input type=\"range\" defaultValue={0.8} min={0.5} max={1} step={0.01} onChange={(e) => this.props.setPeakValue(parseFloat(e.target.value))} />\n              <input type=\"range\" defaultValue={0.2} min={0} max={0.5} step={0.01} onChange={(e) => this.props.setValleyValue(parseFloat(e.target.value))} />\n            </Form.Group>\n            <Form.Group>\n              <Form.Check defaultChecked={true} onClick={(e) => this.props.setGlobalRange()} type=\"checkbox\" label=\"Use Global Min/Max\"></Form.Check>\n            </Form.Group>\n          </Collapsible>\n          <Collapsible trigger=\"Layers\"> \n            <Form.Check defaultChecked={true} onClick={(e) => this.props.toggleTerrainLayer()} type=\"checkbox\" label=\"Terrain Layer\"/>\n            <Form.Check defaultChecked={true} onClick={(e) => this.props.toggleNodeLayer()} type=\"checkbox\" label=\"Node Layer\"/>\n          </Collapsible>\n        </Form>\n        </ div>\n      );\n    }\n  }\n\nexport default Sidebar;","/* The controller can register callbacks for various events on a canvas:\n *\n * mousemove: function(prevMouse, curMouse, evt)\n *     receives both regular mouse events, and single-finger drags (sent as a left-click),\n *\n * press: function(curMouse, evt)\n *     receives mouse click and touch start events\n *\n * wheel: function(amount)\n *     mouse wheel scrolling\n */\nexport class Controller {\n    public mousemove : ((prevMouse : number[], curMouse : number[], evt : MouseEvent) => void) | null;\n    public press : ((curMouse : number[], evt : MouseEvent) => void) | null;\n    public wheel : ((amount : number) => void) | null;\n\n    constructor()\n    {\n        this.mousemove = null;\n        this.press = null;\n        this.wheel = null;\n    }\n\n    registerForCanvas(canvas : HTMLCanvasElement)\n    {\n        var prevMouse : number[] | null = null;\n        var self = this;\n        canvas.addEventListener(\"mousemove\", function(evt : MouseEvent) {\n            evt.preventDefault();\n            var rect = canvas.getBoundingClientRect();\n            var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            if (!prevMouse) {\n                prevMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            } else if (self.mousemove) {\n                self.mousemove(prevMouse, curMouse, evt);\n            }\n            prevMouse = curMouse;\n        });\n\n        canvas.addEventListener(\"mousedown\", function(evt : MouseEvent) {\n            evt.preventDefault();\n            var rect = canvas.getBoundingClientRect();\n            var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            if (self.press) {\n                self.press(curMouse, evt);\n            }\n        });\n\n        canvas.addEventListener(\"wheel\", function(evt) {\n            evt.preventDefault();\n            if (self.wheel) {\n                self.wheel(-evt.deltaY);\n            }\n        });\n\n        canvas.oncontextmenu = function(evt) {\n            evt.preventDefault();\n        };\n    }\n}\n\n","import { compute_terrain, normalize_terrain } from './wgsl';\n\nclass TerrainGenerator {\n    public rangeBuffer : GPUBuffer;\n    public pixelValueBuffer : GPUBuffer;\n    public paramsBuffer : GPUBuffer;\n    public nodeDataBuffer : GPUBuffer;\n    public device : GPUDevice;\n    public width : number;\n    public height : number;\n    public computeTerrainPipeline : GPUComputePipeline;\n    public normalizeTerrainPipeline : GPUComputePipeline;\n    public computeTerrainBGLayout : GPUBindGroupLayout;\n    public normalizeTerrainBGLayout : GPUBindGroupLayout;\n    public nodeData : Array<number> = [];\n    \n    constructor(device : GPUDevice, width, height) {\n        this.device = device;\n        this.width = width;\n        this.height = height;\n\n        this.nodeDataBuffer = this.device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.rangeBuffer = this.device.createBuffer({\n            size: 2 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        });\n\n        var storage : GPUBufferBindingType = \"storage\";\n        var uniform : GPUBufferBindingType = \"uniform\";\n        this.computeTerrainBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: uniform,\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                }\n            ],\n        });\n\n        this.computeTerrainPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [this.computeTerrainBGLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: compute_terrain,\n                }),\n                entryPoint: \"main\",\n            },\n        });\n\n        this.normalizeTerrainBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: uniform,\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                }\n            ],\n        });\n\n        this.normalizeTerrainPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [this.normalizeTerrainBGLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: normalize_terrain,\n                }),\n                entryPoint: \"main\",\n            },\n        });\n\n        // Create a buffer to store the params, output, and min/max\n        this.paramsBuffer = device.createBuffer({\n            size: 8 * 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.pixelValueBuffer = device.createBuffer({\n            size: this.width * this.height * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        });\n    }\n\n    computeTerrain(nodeData = this.nodeData, widthFactor = 1000, translation = [0, 0, 1, 1], globalRange : null | GPUBuffer = null) {\n        if (nodeData.length == 0) {\n            return;\n        }\n        this.nodeData = nodeData;\n        // Set up node data buffer\n        this.nodeDataBuffer = this.device.createBuffer({\n            size: nodeData.length * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true,\n        });\n        new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\n        this.nodeDataBuffer.unmap();\n\n        // Have to reset range buffer unless global range checked\n        if (!globalRange) {\n            this.rangeBuffer = this.device.createBuffer({\n                size: 2 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            });\n        } else {\n            this.rangeBuffer = globalRange;\n        }\n\n        // Set up params (image width, height, node length, and width factor)\n        var upload = this.device.createBuffer({\n            size: 8 * 4,\n            usage: GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: true,\n        });\n        var mapping = upload.getMappedRange();\n        new Uint32Array(mapping).set([this.width, this.height, nodeData.length / 4]);\n        new Float32Array(mapping).set([widthFactor, translation[0], translation[1], translation[2], translation[3]], 3);\n        upload.unmap();\n        //this.device.createQuerySet({})\n        var commandEncoder = this.device.createCommandEncoder();\n        //commandEncoder.writeTimestamp();\n        commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 8 * 4);\n        // Create bind group\n        var bindGroup = this.device.createBindGroup({\n            layout: this.computeTerrainBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.nodeDataBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.paramsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.pixelValueBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: this.rangeBuffer,\n                    },\n                },\n            ],\n        });\n\n        // Run compute terrain pass\n        var pass = commandEncoder.beginComputePass();\n        pass.setBindGroup(0, bindGroup);\n        pass.setPipeline(this.computeTerrainPipeline);\n        pass.dispatch(this.width, this.height, 1);\n        //commandEncoder.writeTimestamp();\n        // await this.device.queue.onSubmittedWorkDone();\n\n        // Look into submitting normalization and compute in one pass to improve speed, remove synchronizations\n        // Use writetimestamp for more accurate kernel timing\n\n        // Run normalize terrain pass\n        var bindGroup = this.device.createBindGroup({\n            layout: this.normalizeTerrainBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.pixelValueBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.paramsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.rangeBuffer,\n                    },\n                },\n            ],\n        });\n        pass.setBindGroup(0, bindGroup);\n        pass.setPipeline(this.normalizeTerrainPipeline);\n        pass.dispatch(this.width, this.height, 1);\n        pass.endPass();\n        this.device.queue.submit([commandEncoder.finish()]);\n        // await this.device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport default TerrainGenerator;","export const  compute_terrain = `// compute terrain wgsl\nstruct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\n[[block]] struct Nodes {\n    nodes : array<Node>;\n};\n[[block]] struct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n  view_box : vec4<f32>;\n};\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Range {\n    x : atomic<i32>;\n    y : atomic<i32>;\n};\n\n[[group(0), binding(0)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(3)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    var x : f32 = f32(global_id.x) / f32(uniforms.image_width);\n    var y : f32 = f32(global_id.y) / f32(uniforms.image_height);\n    x = x * (uniforms.view_box.z - uniforms.view_box.x) + uniforms.view_box.x;\n    y = y * (uniforms.view_box.w - uniforms.view_box.y) + uniforms.view_box.y;\n    var value : f32 = 0.0;\n\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\n        var sqrDistance : f32 = (x - nodes.nodes[i].x) * (x - nodes.nodes[i].x) + (y - nodes.nodes[i].y) * (y - nodes.nodes[i].y);\n        value = value + nodes.nodes[i].value / (sqrDistance * uniforms.width_factor + 1.0);\n    }\n    value = value * 100.0;\n    ignore(atomicMin(&range.x, i32(floor(value))));\n    ignore(atomicMax(&range.y, i32(ceil(value))));\n    pixels.pixels[pixel_index] = value;\n}`;\nexport const  normalize_terrain = `// normalize terrain wgsl\n[[block]] struct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n};\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Range {\n    x : i32;\n    y : i32;\n};\n\n[[group(0), binding(0)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    pixels.pixels[pixel_index] = (pixels.pixels[pixel_index] - f32(range.x)) / f32(range.y - range.x);\n}`;\nexport const  display_2d_vert = `// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] fragPosition: vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec4<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    output.Position = position;\n    output.fragPosition = 0.5 * (position + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n    return output;\n}\n\n\n`;\nexport const  display_2d_frag = `// Fragment shader\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Uniforms {\n    peak_value : f32;\n    valley_value : f32;\n};\n[[block]] struct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(0)]] var myTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(2)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn outside_grid(p : vec2<u32>) -> bool {\n    return any(p == vec2<u32>(u32(0))) || p.x == image_size.width || p.y == image_size.height;\n}\n\n[[stage(fragment)]]\nfn main([[location(0)]] fragPosition: vec4<f32>) -> [[location(0)]] vec4<f32> {\n    var ufragPos : vec4<u32> = vec4<u32>(fragPosition * f32(image_size.width));\n    var pixelIndex : u32 = ufragPos.x + ufragPos.y * image_size.width;\n    var value : f32 = pixels.pixels[pixelIndex];\n    if (!outside_grid(ufragPos.xy)){\n        var neighbor_peaks : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] >= uniforms.peak_value ,\n            pixels.pixels[pixelIndex - u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + image_size.width] >= uniforms.peak_value\n        );\n        var neighbor_valleys : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex - u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + image_size.width] <= uniforms.valley_value\n        ); \n        if (any(neighbor_peaks) && value < uniforms.peak_value) {\n            return vec4<f32>(0.8, 0.5, 0.5, 1.0);\n        }\n        if (any(neighbor_valleys) && value > uniforms.valley_value) {\n            return vec4<f32>(0.5, 0.3, 0.3, 1.0);\n        }\n    }\n    var color : vec4<f32> = textureLoad(myTexture, vec2<i32>(i32(value * 180.0), 1), 0);\n    return color;\n}`;\nexport const  display_3d_vert = `// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] vray_dir: vec3<f32>;\n  [[location(1), interpolate(flat)]] transformed_eye: vec3<f32>;\n};\n[[block]] struct Uniforms {\n  proj_view : mat4x4<f32>;\n  eye_pos : vec4<f32>;\n};\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec3<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    var volume_translation : vec3<f32> = vec3<f32>(-0.5, -0.5, -0.5);\n    output.Position = uniforms.proj_view * vec4<f32>(position + volume_translation, 1.0);\n    output.transformed_eye = uniforms.eye_pos.xyz - volume_translation;\n    output.vray_dir = position - output.transformed_eye;\n    return output;\n}`;\nexport const  display_3d_frag = `// Fragment shader\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(1)]] var colormap: texture_2d<f32>;\n[[group(0), binding(2)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn intersect_box(orig : vec3<f32>, dir : vec3<f32>, box_min : vec3<f32>, box_max : vec3<f32>) -> vec2<f32> {\n    let inv_dir : vec3<f32> = 1.0 / dir;\n    let tmin_tmp : vec3<f32> = (box_min - orig) * inv_dir;\n    let tmax_tmp : vec3<f32> = (box_max - orig) * inv_dir;\n    var tmin : vec3<f32> = min(tmin_tmp, tmax_tmp);\n    var tmax : vec3<f32> = max(tmin_tmp, tmax_tmp);\n    var t0 : f32 = max(tmin.x, max(tmin.y, tmin.z));\n    var t1 : f32 = min(tmax.x, min(tmax.y, tmax.z));\n    return vec2<f32>(t0, t1);\n}\n\nfn outside_grid(p : vec3<f32>, volumeDims : vec3<f32>) -> bool {\n    return any(p < vec3<f32>(0.0)) || any(p >= volumeDims);\n}\n\n[[stage(fragment)]]\nfn main(\n  [[location(0)]] vray_dir: vec3<f32>, \n  [[location(1), interpolate(flat)]] transformed_eye : vec3<f32>\n)-> [[location(0)]] vec4<f32> {\n    var ray_dir : vec3<f32> = normalize(vray_dir);\n    var longest_axis : f32 = f32(max(image_size.width, image_size.height));\n    let volume_dims : vec3<f32> = vec3<f32>(f32(image_size.width), f32(image_size.height), f32(longest_axis));\n    let vol_eye : vec3<f32> = transformed_eye * volume_dims;\n    let grid_ray_dir : vec3<f32> = normalize(ray_dir * volume_dims);\n\n    var t_hit : vec2<f32> = intersect_box(vol_eye, grid_ray_dir, vec3<f32>(0.0), volume_dims - 1.0);\n    if (t_hit.x > t_hit.y) { \n        discard;\n    }\n\n    t_hit.x = max(t_hit.x, 0.0);\n\n    var p : vec3<f32> = (vol_eye + t_hit.x * grid_ray_dir);\n    p = clamp(p, vec3<f32>(0.0), volume_dims - 2.0);\n    let inv_grid_ray_dir : vec3<f32> = 1.0 / grid_ray_dir;\n    let start_cell : vec3<f32> = floor(p);\n    let t_max_neg : vec3<f32> = (start_cell - vol_eye) * inv_grid_ray_dir;\n    let t_max_pos : vec3<f32> = (start_cell + 1.0 - vol_eye) * inv_grid_ray_dir;\n    let is_neg_dir : vec3<f32> = vec3<f32>(grid_ray_dir < vec3<f32>(0.0));\n    // Pick between positive/negative t_max based on the ray sign\n    var t_max : vec3<f32> = mix(t_max_pos, t_max_neg, is_neg_dir);\n    let grid_step : vec3<i32> = vec3<i32>(sign(grid_ray_dir));\n    // Note: each voxel is a 1^3 box on the grid\n    let t_delta : vec3<f32> = abs(inv_grid_ray_dir);\n\n    var t_prev : f32 = t_hit.x;\n    // Traverse the grid\n    loop {\n        if (outside_grid(p, volume_dims)) { break; }\n        let v000 : vec3<u32> = vec3<u32>(p);\n        var pixel_index : u32 = v000.x + v000.y * image_size.width;\n        var value : f32 = pixels.pixels[pixel_index];\n        if (f32(v000.z) > longest_axis / 2.0) {\n            if (value * longest_axis >= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } elseif (f32(v000.z) < longest_axis / 2.0) {\n            if (value * longest_axis <= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } else {\n            return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n        }\n\n        let t_next : f32 = min(t_max.x, min(t_max.y, t_max.z));\n        t_prev = t_next;\n        if (t_next == t_max.x) {\n            p.x = p.x + f32(grid_step.x);\n            t_max.x = t_max.x + t_delta.x;\n        } elseif (t_next == t_max.y) {\n            p.y = p.y + f32(grid_step.y);\n            t_max.y = t_max.y + t_delta.y;\n        } else {\n            p.z = p.z + f32(grid_step.z);\n            t_max.z = t_max.z + t_delta.z;\n        }\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n}\n\n`;\nexport const  node_vert = `// Vertex shader\nstruct VertexOutput {\n    [[builtin(position)]] Position : vec4<f32>;\n    [[location(0)]] position: vec2<f32>;\n    [[location(1), interpolate(flat)]] center : vec2<f32>;\n};\n[[block]] struct Uniforms {\n  view_box : vec4<f32>;\n};\n\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec2<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\n    var x : f32 = (position.x - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\n    var y : f32 = (position.y - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\n    output.Position = vec4<f32>(x, y, 0.0, 1.0);\n    output.position = position;\n    // flat interpolated position will give bottom right corner, so translate to center\n    output.center = output.position + vec2<f32>(-0.01, 0.01);\n    return output;\n}`;\nexport const  node_frag = `[[stage(fragment)]]\nfn main([[location(0)]] position: vec2<f32>, [[location(1), interpolate(flat)]] center: vec2<f32>) -> [[location(0)]] vec4<f32> {\n    if (distance(position, center) > 0.005) {\n        discard;\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, (1.0 - distance(position, center) * 200));\n}\n`;\n","import { Controller } from './ez_canvas_controller';\nimport TerrainGenerator from './terrain_generator';\nimport { display_2d_vert, display_2d_frag, node_vert, node_frag } from './wgsl';\n\nclass Renderer {\n  public uniform2DBuffer : GPUBuffer | null = null;\n  public terrainGenerator : TerrainGenerator | null = null;\n  public device : GPUDevice;\n  public bindGroup2D : GPUBindGroup | null = null;\n  public nodeBindGroup : GPUBindGroup | null = null;\n  public nodePositionBuffer : GPUBuffer | null = null;\n  public nodePipeline : GPURenderPipeline | null = null;\n  public nodeLength : number = 1;\n  public rangeBuffer : GPUBuffer | null = null;\n  public nodeToggle : boolean = true;\n  public terrainToggle : boolean = true;\n\n  constructor(adapter : GPUAdapter, device : GPUDevice, canvasRef : React.RefObject<HTMLCanvasElement>, colormap : ImageBitmap) {\n    this.device = device;\n    // Check that canvas is active\n    if (canvasRef.current === null) return;\n    const context = canvasRef.current.getContext('webgpu')!;\n  \n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const presentationSize = [\n      canvasRef.current.clientWidth * devicePixelRatio,\n      canvasRef.current.clientHeight * devicePixelRatio,\n    ];\n    const presentationFormat = context.getPreferredFormat(adapter);\n  \n    context.configure({\n      device,\n      format: presentationFormat,\n      size: presentationSize,\n    });\n\n    this.rangeBuffer = this.device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    this.nodePositionBuffer = device.createBuffer({\n      size: 6 * 2 * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(this.nodePositionBuffer.getMappedRange()).set([\n      1, -1,\n      -1, -1,\n      -1, 1,\n      1, -1,\n      -1, 1,\n      1, 1,\n    ]);\n    this.nodePositionBuffer.unmap();\n\n    this.nodePipeline = device.createRenderPipeline({\n      vertex: {\n        module: device.createShaderModule({\n          code: node_vert,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: 2 * 4,\n            attributes: [\n              {\n                format: \"float32x2\" as GPUVertexFormat,\n                offset: 0,\n                shaderLocation: 0,\n              }\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: node_frag,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: 'triangle-list',\n      },\n      multisample: {\n        count: 4\n      }\n    });\n  \n    const pipeline = device.createRenderPipeline({\n      vertex: {\n        module: device.createShaderModule({\n          code: display_2d_vert,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: 4 * 4,\n            attributes: [\n              {\n                format: \"float32x4\" as GPUVertexFormat,\n                offset: 0,\n                shaderLocation: 0,\n              }\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: display_2d_frag,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: 'triangle-list',\n      },\n      multisample: {\n        count: 4\n      }\n    });\n\n    // Vertices to render\n    var dataBuf2D = device.createBuffer({\n      size: 6 * 4 * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(dataBuf2D.getMappedRange()).set([\n      1, -1, 0, 1,  // position\n      -1, -1, 0, 1, // position\n      -1, 1, 0, 1,   // position\n      1, -1, 0, 1,  // position\n      -1, 1, 0, 1, // position\n      1, 1, 0, 1,   // position\n    ]);\n    dataBuf2D.unmap();\n\n    // Set up uniform buffers for bind group\n    this.uniform2DBuffer = device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(this.uniform2DBuffer, 0, new Float32Array([0.8, 0.2]), 0, 2);\n    const imageSizeBuffer = device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.UNIFORM,\n      mappedAtCreation: true\n    });\n    new Uint32Array(imageSizeBuffer.getMappedRange()).set(presentationSize);\n    imageSizeBuffer.unmap();\n    const nodeDataBuffer = device.createBuffer({\n      size: 16,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    // Load colormap texture\n    const colorTexture = device.createTexture({\n      size: [colormap.width, colormap.height, 1],\n      format: \"rgba8unorm\",\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: colormap },\n      { texture: colorTexture },\n      [colormap.width, colormap.height, 1]\n    );\n\n    this.terrainGenerator = new TerrainGenerator(device, presentationSize[0], presentationSize[1]);\n\n    this.bindGroup2D = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: colorTexture.createView(),\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: this.terrainGenerator.pixelValueBuffer,\n          }\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: this.uniform2DBuffer,\n          },\n        },\n        {\n          binding: 3,\n          resource: {\n            buffer: imageSizeBuffer,\n          }\n        }\n      ],\n    });\n    // this.nodeBindGroup = device.createBindGroup({\n    //   layout: pipeline.getBindGroupLayout(1),\n    //   entries: [\n    //     {\n    //       binding: 0,\n    //       resource: {\n    //         buffer: nodeDataBuffer,\n    //       }\n    //     }\n    //   ]\n    // });\n    var viewBoxBuffer = device.createBuffer({\n      size: 4 * 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array([0, 0, 1, 1]), 0, 4);\n    var translation = [0, 0, 1, 1];\n    var newTranslation = [0, 0, 1, 1];\n    var controller = new Controller();\n    var terrainGenerator = this.terrainGenerator;\n    var render = this;\n    controller.mousemove = function (prev, cur, evt) {\n      if (evt.buttons == 1) {\n        var change = [(cur[0] - prev[0]) * (translation[2] - translation[0]) / presentationSize[0], (prev[1] - cur[1]) * (translation[3] - translation[1]) / presentationSize[1]];\n        newTranslation = [newTranslation[0] - change[0], newTranslation[1] - change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]]\n        if (Math.abs(newTranslation[0] - translation[0]) > 0.03 * (translation[2] - translation[0]) || Math.abs(newTranslation[1] - translation[1]) > 0.03 * (translation[3] - translation[1])) {\n          translation = newTranslation;\n          if (render.terrainToggle) {\n            terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer);\n          }\n          if (render.nodeToggle) {\n            device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array(translation), 0, 4);\n          }\n        }\n      }\n    };\n    controller.wheel = function (amt) {\n      var change = [amt / 10000, amt / 10000];\n      newTranslation = [newTranslation[0] + change[0], newTranslation[1] + change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]];\n      if (newTranslation[2] - newTranslation[0] > 0.01 && newTranslation[3] - newTranslation[1] > 0.01) {\n        translation = newTranslation;\n        if (render.terrainToggle) {\n          terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer);\n        }\n        if (render.nodeToggle) {\n          device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array(translation), 0, 4);\n        }\n      } else {\n        newTranslation = translation;\n      }\n    };\n    controller.registerForCanvas(canvasRef.current);\n    var viewBoxBindGroup = device.createBindGroup({\n      layout: this.nodePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: viewBoxBuffer,\n          },\n        },\n      ],\n    });\n\n    const texture = device.createTexture({\n      size: presentationSize,\n      sampleCount: 4,\n      format: presentationFormat,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    const view = texture.createView();\n\n    var render = this;\n    function frame() {\n        // Sample is no longer the active page.\n        if (!canvasRef.current) return;\n\n        const commandEncoder = device.createCommandEncoder();\n\n        const renderPassDescriptor: GPURenderPassDescriptor = {\n        colorAttachments: [\n          {\n            view,\n            resolveTarget: context.getCurrentTexture().createView(),\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\n            storeOp: \"discard\" as GPUStoreOp,\n          },\n        ],\n        };\n\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        if (render.terrainToggle) {\n          passEncoder.setPipeline(pipeline);\n          passEncoder.setVertexBuffer(0, dataBuf2D);\n          passEncoder.setBindGroup(0, render.bindGroup2D!);\n          passEncoder.draw(6, 1, 0, 0);\n        }\n        if (render.nodeToggle) {\n          passEncoder.setPipeline(render.nodePipeline!);\n          passEncoder.setVertexBuffer(0, render.nodePositionBuffer!);\n          passEncoder.setBindGroup(0, viewBoxBindGroup);\n          passEncoder.draw(render.nodeLength * 6, 1, 0, 0);\n        }\n        passEncoder.endPass();\n  \n        device.queue.submit([commandEncoder.finish()]);\n        requestAnimationFrame(frame);\n    }\n\n    requestAnimationFrame(frame);\n\n  }\n\n  setNodeData(nodeData : Array<number>) {\n    // TODO: Implement the translation and global range options\n    this.terrainGenerator!.computeTerrain(nodeData, undefined, undefined, this.rangeBuffer);\n    var nodePositions : Array<number> = [];\n    var radius : number = 0.01;\n    for (var i = 0; i < nodeData.length; i+=4) {\n      var x = nodeData[i+1] * 2 - 1;\n      var y = nodeData[i+2] * 2 - 1;\n      nodePositions.push(\n        x + radius, y - radius,\n        x - radius, y - radius,\n        x - radius, y + radius,\n        x + radius, y - radius,\n        x - radius, y + radius,\n        x + radius, y + radius\n      );\n    }\n    this.nodePositionBuffer = this.device.createBuffer({\n      size: nodePositions.length * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(this.nodePositionBuffer.getMappedRange()).set(nodePositions);\n    this.nodePositionBuffer.unmap();\n    this.nodeLength = nodeData.length / 4;\n\n    // this.nodeBindGroup = this.device.createBindGroup({\n    //   layout: this.nodePipeline!.getBindGroupLayout(1),\n    //   entries: [\n    //     {\n    //       binding: 0,\n    //       resource: {\n    //         buffer: this.terrainGenerator!.nodeDataBuffer,\n    //       }\n    //     }\n    //   ]\n    // });\n  }\n\n  setWidthFactor(widthFactor : number) {\n    this.terrainGenerator!.computeTerrain(undefined, widthFactor, undefined, this.rangeBuffer);\n  }\n\n  setPeakValue(value : number) {\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 0, new Float32Array([value]), 0, 1);\n  }\n\n  setValleyValue(value : number) {\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 4, new Float32Array([value]), 0, 1);\n  }\n\n  setGlobalRange() {\n    if (this.rangeBuffer) {\n      this.rangeBuffer = null;\n    } else {\n      this.rangeBuffer = this.device.createBuffer({\n        size: 2 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });    \n    }\n  }\n\n  toggleTerrainLayer() {\n    this.terrainToggle = !this.terrainToggle;\n  }\n\n  toggleNodeLayer() {\n    this.nodeToggle = !this.nodeToggle;\n  }\n}\nexport default Renderer;\n\n","import React from 'react';\nimport Sidebar from './Sidebar';\nimport { createRef, MutableRefObject } from 'react';\nimport Renderer from \"../webgpu/render\";\nimport colormap from './rainbow.png';\n\ntype PageState = {\n    widthFactor: number,\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    renderer: Renderer | null,\n}\nclass Page extends React.Component<{}, PageState> {\n    constructor(props) {\n        super(props);\n        this.state = {widthFactor: 1000, canvasRef: createRef<HTMLCanvasElement | null>(), renderer: null};\n    }\n\n    async componentDidMount() {\n        const adapter = (await navigator.gpu.requestAdapter())!;\n        const device = await adapter.requestDevice(); \n        var colormapImage = new Image();\n        colormapImage.src = colormap;\n        await colormapImage.decode();\n        const imageBitmap = await createImageBitmap(colormapImage);\n        this.setState({renderer: new Renderer(adapter, device, this.state.canvasRef, imageBitmap)});\n    }\n\n    setNodeData(nodeData : Array<number>) {\n        this.state.renderer!.setNodeData(nodeData);\n    }\n\n    setWidthFactor(widthFactor : number) {\n        this.state.renderer!.setWidthFactor(widthFactor);\n    }\n\n    setPeakValue(value : number) {\n        this.state.renderer!.setPeakValue(value);\n    }\n\n    setValleyValue(value : number) {\n        this.state.renderer!.setValleyValue(value);\n    }\n\n    setGlobalRange() {\n        this.state.renderer!.setGlobalRange();\n    }\n\n    toggleNodeLayer() {\n        this.state.renderer!.toggleNodeLayer();\n    }\n\n    toggleTerrainLayer() {\n        this.state.renderer!.toggleTerrainLayer();\n    }\n  \n    render() {\n      return (\n        <div>\n            <Sidebar \n                setValleyValue={this.setValleyValue.bind(this)} \n                setPeakValue={this.setPeakValue.bind(this)} \n                setWidthFactor={this.setWidthFactor.bind(this)} \n                setNodeData={this.setNodeData.bind(this)} \n                setGlobalRange={this.setGlobalRange.bind(this)}\n                toggleNodeLayer={this.toggleNodeLayer.bind(this)}\n                toggleTerrainLayer={this.toggleTerrainLayer.bind(this)}\n            />\n            <div className=\"canvasContainer\">\n                <canvas ref={this.state.canvasRef} width={800} height={800}></canvas>\n            </div>\n        </div>\n      );\n    }\n  }\n\nexport default Page;","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAABCAYAAAB3yoT0AAAAOklEQVQokc3QsQrAIBBEwTEI+v9fG0E8e0kKu6se7HRbiFBR0X+azVpg4j36teWwx0px3Y2VkeK6K9uFnl0AGQ1BkQAAAABJRU5ErkJggg==\"","import './App.css';\nimport Page from './components/Page';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Page />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode >\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}