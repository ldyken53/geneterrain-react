{"version":3,"sources":["components/Sidebar.tsx","webgpu/ez_canvas_controller.ts","webgpu/terrain_generator.ts","webgpu/wgsl.tsx","webgpu/render.tsx","components/Page.tsx","components/rainbow.png","App.tsx","index.tsx"],"names":["Sidebar","props","state","nodeData","handleSubmit","bind","readFiles","event","preventDefault","this","setNodeData","files","target","console","log","nodeIDToValue","edgeReader","FileReader","onload","layoutReader","layoutData","result","split","parts","push","parseFloat","setState","readAsText","nodeReader","rawNodes","element","className","Form","style","color","onSubmit","Group","controlId","Label","Control","type","multiple","onChange","Button","variant","value","defaultValue","min","max","e","setWidthFactor","step","setPeakValue","setValleyValue","Check","defaultChecked","onClick","setGlobalRange","label","React","Component","Controller","mousemove","press","wheel","canvas","prevMouse","self","addEventListener","evt","rect","getBoundingClientRect","curMouse","clientX","left","clientY","top","deltaY","oncontextmenu","TerrainGenerator","device","width","height","rangeBuffer","pixelValueBuffer","paramsBuffer","nodeDataBuffer","computeTerrainPipeline","normalizeTerrainPipeline","computeTerrainBGLayout","normalizeTerrainBGLayout","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","storage","uniform","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","UNIFORM","widthFactor","translation","globalRange","length","mappedAtCreation","Float32Array","getMappedRange","set","unmap","upload","mapping","Uint32Array","commandEncoder","createCommandEncoder","copyBufferToBuffer","bindGroup","createBindGroup","resource","pass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","Renderer","adapter","canvasRef","colormap","uniform2DBuffer","terrainGenerator","bindGroup2D","nodeBindGroup","nodePositionBuffer","nodePipeline","nodeLength","current","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","configure","format","VERTEX","createRenderPipeline","vertex","buffers","arrayStride","attributes","offset","shaderLocation","fragment","targets","primitive","topology","depthStencil","depthWriteEnabled","depthCompare","pipeline","dataBuf2D","writeBuffer","imageSizeBuffer","colorTexture","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","depthTexture","depthOrArrayLayers","getBindGroupLayout","createView","viewBoxBuffer","newTranslation","controller","render","prev","cur","buttons","change","Math","abs","computeTerrain","undefined","amt","registerForCanvas","viewBoxBindGroup","requestAnimationFrame","frame","renderPassDescriptor","colorAttachments","view","getCurrentTexture","loadValue","r","g","b","a","storeOp","depthStencilAttachment","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","passEncoder","beginRenderPass","setVertexBuffer","draw","nodePositions","radius","i","x","y","Page","createRef","renderer","navigator","gpu","requestAdapter","requestDevice","colormapImage","Image","src","decode","createImageBitmap","imageBitmap","ref","App","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4c04f2c7.chunk.js","sourcesContent":["import React from 'react';\nimport {Form, Button} from \"react-bootstrap\";\n\ntype SidebarProps = {\n  setNodeData: (nodeData : Array<number>) => void,\n  setWidthFactor: (widthFactor : number) => void,\n  setPeakValue: (value : number) => void,\n  setValleyValue: (value : number) => void,\n  setGlobalRange: () => void\n}\ntype SidebarState = {\n  nodeData: Array<number>\n}\nclass Sidebar extends React.Component<SidebarProps, SidebarState> {\n    constructor(props) {\n      super(props);\n      this.state = {nodeData: []};\n  \n      this.handleSubmit = this.handleSubmit.bind(this);\n      this.readFiles = this.readFiles.bind(this);\n    }\n  \n    handleSubmit(event) {\n      event.preventDefault();\n      this.props.setNodeData(this.state.nodeData);\n    }\n\n    readFiles(event : React.ChangeEvent<HTMLInputElement>) {\n        const files : FileList = event.target.files!;\n        console.log(files);\n        var nodeIDToValue = {};\n        var nodeData : Array<number> = [];\n        const edgeReader = new FileReader();\n        edgeReader.onload = (event) => {\n        //   var edgeData = (edgeReader.result as string).split(\"\\n\");\n        //   for (var element of edgeData) {\n        //     var parts = element.split(\"\\t\");\n        //     if (nodeIDToValue[parts[0]] && nodeIDToValue[parts[1]]) {\n        //       nodeElements.push({ data: { source: parts[0], target: parts[1], weight: parseFloat(parts[2]) } });\n        //     }\n        //   }\n        //   await render(nodeData, index);\n            console.log(\"not yet implemented edges\");\n        };\n        const layoutReader = new FileReader();\n        layoutReader.onload = (event) => {\n          var layoutData = (layoutReader.result as string).split(\"\\n\");\n          for (var element of layoutData) {\n            var parts = element.split(\"\\t\");\n            if (nodeIDToValue[parts[0]]) {\n              // Pushes values to node data in order of struct for WebGPU:\n              // nodeValue, nodeX, nodeY, nodeSize\n              nodeData.push(parseFloat(nodeIDToValue[parts[0]]), parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));\n            }\n          }\n          this.setState({nodeData: nodeData});\n          edgeReader.readAsText(files[1]);\n        };\n        const nodeReader = new FileReader();\n        nodeReader.onload = (event) => {\n          var rawNodes = (nodeReader.result as string).split(\"\\n\");\n          for (var element of rawNodes) {\n            nodeIDToValue[element.split(\"\\t\")[0]] = element.split(\"\\t\")[1]\n          }\n          layoutReader.readAsText(files[1]);\n        };\n        nodeReader.readAsText(files[0]);\n    }\n  \n    render() {\n      return (\n        <div className=\"sidebar\"> \n        <Form style={{color: 'white'}} onSubmit={this.handleSubmit}>\n          <Form.Group controlId=\"formFile\" className=\"mt-3 mb-3\">\n            <Form.Label>Select Example Files</Form.Label>\n            <Form.Control className=\"form-control\" type=\"file\" multiple onChange={this.readFiles}/>\n            <Button className=\"mt-2\" type=\"submit\" variant=\"secondary\" value=\"Submit\">Submit</ Button>\n          </Form.Group>\n          <Form.Group> \n            <Form.Label> Width Factor </ Form.Label>\n            <br/>\n            <input type=\"range\" defaultValue={1000} min={0} max={2000} onChange={(e) => this.props.setWidthFactor(parseFloat(e.target.value))} />\n          </Form.Group>\n          <Form.Group> \n            <Form.Label> Peak and Valley Values </ Form.Label>\n            <br/>\n            <input type=\"range\" defaultValue={0.8} min={0.5} max={1} step={0.01} onChange={(e) => this.props.setPeakValue(parseFloat(e.target.value))} />\n            <input type=\"range\" defaultValue={0.2} min={0} max={0.5} step={0.01} onChange={(e) => this.props.setValleyValue(parseFloat(e.target.value))} />\n          </Form.Group>\n          <Form.Group>\n            <Form.Check defaultChecked={true} onClick={(e) => this.props.setGlobalRange()} type=\"checkbox\" label=\"Use Global Min/Max\"></Form.Check>\n          </Form.Group>\n        </Form>\n        </ div>\n      );\n    }\n  }\n\nexport default Sidebar;","function pointDist(a, b)\n{\n    var v = [b[0] - a[0], b[1] - a[1]];\n    return Math.sqrt(Math.pow(v[0], 2.0) + Math.pow(v[1], 2.0));\n}\n\n/* The controller can register callbacks for various events on a canvas:\n *\n * mousemove: function(prevMouse, curMouse, evt)\n *     receives both regular mouse events, and single-finger drags (sent as a left-click),\n *\n * press: function(curMouse, evt)\n *     receives mouse click and touch start events\n *\n * wheel: function(amount)\n *     mouse wheel scrolling\n */\nexport class Controller {\n    public mousemove : ((prevMouse : number[], curMouse : number[], evt : MouseEvent) => void) | null;\n    public press : ((curMouse : number[], evt : MouseEvent) => void) | null;\n    public wheel : ((amount : number) => void) | null;\n\n    constructor()\n    {\n        this.mousemove = null;\n        this.press = null;\n        this.wheel = null;\n    }\n\n    registerForCanvas(canvas : HTMLCanvasElement)\n    {\n        var prevMouse : number[] | null = null;\n        var self = this;\n        canvas.addEventListener(\"mousemove\", function(evt : MouseEvent) {\n            evt.preventDefault();\n            var rect = canvas.getBoundingClientRect();\n            var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            if (!prevMouse) {\n                prevMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            } else if (self.mousemove) {\n                self.mousemove(prevMouse, curMouse, evt);\n            }\n            prevMouse = curMouse;\n        });\n\n        canvas.addEventListener(\"mousedown\", function(evt : MouseEvent) {\n            evt.preventDefault();\n            var rect = canvas.getBoundingClientRect();\n            var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            if (self.press) {\n                self.press(curMouse, evt);\n            }\n        });\n\n        canvas.addEventListener(\"wheel\", function(evt) {\n            evt.preventDefault();\n            if (self.wheel) {\n                self.wheel(-evt.deltaY);\n            }\n        });\n\n        canvas.oncontextmenu = function(evt) {\n            evt.preventDefault();\n        };\n    }\n}\n\n","import { compute_terrain, normalize_terrain } from './wgsl';\n\nclass TerrainGenerator {\n    public rangeBuffer : GPUBuffer;\n    public pixelValueBuffer : GPUBuffer;\n    public paramsBuffer : GPUBuffer;\n    public nodeDataBuffer : GPUBuffer;\n    public device : GPUDevice;\n    public width : number;\n    public height : number;\n    public computeTerrainPipeline : GPUComputePipeline;\n    public normalizeTerrainPipeline : GPUComputePipeline;\n    public computeTerrainBGLayout : GPUBindGroupLayout;\n    public normalizeTerrainBGLayout : GPUBindGroupLayout;\n    public nodeData : Array<number> = [];\n    \n    constructor(device : GPUDevice, width, height) {\n        this.device = device;\n        this.width = width;\n        this.height = height;\n\n        this.nodeDataBuffer = this.device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.rangeBuffer = this.device.createBuffer({\n            size: 2 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        });\n\n        var storage : GPUBufferBindingType = \"storage\";\n        var uniform : GPUBufferBindingType = \"uniform\";\n        this.computeTerrainBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: uniform,\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                }\n            ],\n        });\n\n        this.computeTerrainPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [this.computeTerrainBGLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: compute_terrain,\n                }),\n                entryPoint: \"main\",\n            },\n        });\n\n        this.normalizeTerrainBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: uniform,\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                }\n            ],\n        });\n\n        this.normalizeTerrainPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [this.normalizeTerrainBGLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: normalize_terrain,\n                }),\n                entryPoint: \"main\",\n            },\n        });\n\n        // Create a buffer to store the params, output, and min/max\n        this.paramsBuffer = device.createBuffer({\n            size: 8 * 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.pixelValueBuffer = device.createBuffer({\n            size: this.width * this.height * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        });\n    }\n\n    computeTerrain(nodeData = this.nodeData, widthFactor = 1000, translation = [0, 0, 1, 1], globalRange : null | GPUBuffer = null) {\n        if (nodeData.length == 0) {\n            return;\n        }\n        this.nodeData = nodeData;\n        // Set up node data buffer\n        this.nodeDataBuffer = this.device.createBuffer({\n            size: nodeData.length * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true,\n        });\n        new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\n        this.nodeDataBuffer.unmap();\n\n        // Have to reset range buffer unless global range checked\n        if (!globalRange) {\n            this.rangeBuffer = this.device.createBuffer({\n                size: 2 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            });\n        } else {\n            this.rangeBuffer = globalRange;\n        }\n\n        // Set up params (image width, height, node length, and width factor)\n        var upload = this.device.createBuffer({\n            size: 8 * 4,\n            usage: GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: true,\n        });\n        var mapping = upload.getMappedRange();\n        new Uint32Array(mapping).set([this.width, this.height, nodeData.length / 4]);\n        new Float32Array(mapping).set([widthFactor, translation[0], translation[1], translation[2], translation[3]], 3);\n        upload.unmap();\n        //this.device.createQuerySet({})\n        var commandEncoder = this.device.createCommandEncoder();\n        //commandEncoder.writeTimestamp();\n        commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 8 * 4);\n        // Create bind group\n        var bindGroup = this.device.createBindGroup({\n            layout: this.computeTerrainBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.nodeDataBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.paramsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.pixelValueBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: this.rangeBuffer,\n                    },\n                },\n            ],\n        });\n\n        // Run compute terrain pass\n        var pass = commandEncoder.beginComputePass();\n        pass.setBindGroup(0, bindGroup);\n        pass.setPipeline(this.computeTerrainPipeline);\n        pass.dispatch(this.width, this.height, 1);\n        //commandEncoder.writeTimestamp();\n        // await this.device.queue.onSubmittedWorkDone();\n\n        // Look into submitting normalization and compute in one pass to improve speed, remove synchronizations\n        // Use writetimestamp for more accurate kernel timing\n\n        // Run normalize terrain pass\n        var bindGroup = this.device.createBindGroup({\n            layout: this.normalizeTerrainBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.pixelValueBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.paramsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.rangeBuffer,\n                    },\n                },\n            ],\n        });\n        pass.setBindGroup(0, bindGroup);\n        pass.setPipeline(this.normalizeTerrainPipeline);\n        pass.dispatch(this.width, this.height, 1);\n        pass.endPass();\n        this.device.queue.submit([commandEncoder.finish()]);\n        // await this.device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport default TerrainGenerator;","export const  compute_terrain = `// compute terrain wgsl\nstruct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\n[[block]] struct Nodes {\n    nodes : array<Node>;\n};\n[[block]] struct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n  view_box : vec4<f32>;\n};\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Range {\n    x : atomic<i32>;\n    y : atomic<i32>;\n};\n\n[[group(0), binding(0)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(3)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    var x : f32 = f32(global_id.x) / f32(uniforms.image_width);\n    var y : f32 = f32(global_id.y) / f32(uniforms.image_height);\n    x = x * (uniforms.view_box.z - uniforms.view_box.x) + uniforms.view_box.x;\n    y = y * (uniforms.view_box.w - uniforms.view_box.y) + uniforms.view_box.y;\n    var value : f32 = 0.0;\n\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\n        var sqrDistance : f32 = (x - nodes.nodes[i].x) * (x - nodes.nodes[i].x) + (y - nodes.nodes[i].y) * (y - nodes.nodes[i].y);\n        value = value + nodes.nodes[i].value / (sqrDistance * uniforms.width_factor + 1.0);\n    }\n    value = value * 100.0;\n    ignore(atomicMin(&range.x, i32(floor(value))));\n    ignore(atomicMax(&range.y, i32(ceil(value))));\n    pixels.pixels[pixel_index] = value;\n}`;\nexport const  normalize_terrain = `// normalize terrain wgsl\n[[block]] struct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n};\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Range {\n    x : i32;\n    y : i32;\n};\n\n[[group(0), binding(0)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    pixels.pixels[pixel_index] = (pixels.pixels[pixel_index] - f32(range.x)) / f32(range.y - range.x);\n}`;\nexport const  display_2d_vert = `// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] fragPosition: vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec4<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    output.Position = position;\n    output.fragPosition = 0.5 * (position + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n    return output;\n}\n\n\n`;\nexport const  display_2d_frag = `// Fragment shader\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Uniforms {\n    peak_value : f32;\n    valley_value : f32;\n};\n[[block]] struct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(0)]] var myTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(2)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn outside_grid(p : vec2<u32>) -> bool {\n    return any(p == vec2<u32>(u32(0))) || p.x == image_size.width || p.y == image_size.height;\n}\n\n[[stage(fragment)]]\nfn main([[location(0)]] fragPosition: vec4<f32>) -> [[location(0)]] vec4<f32> {\n    var ufragPos : vec4<u32> = vec4<u32>(fragPosition * f32(image_size.width));\n    var pixelIndex : u32 = ufragPos.x + ufragPos.y * image_size.width;\n    var value : f32 = pixels.pixels[pixelIndex];\n    if (!outside_grid(ufragPos.xy)){\n        var neighbor_peaks : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] >= uniforms.peak_value ,\n            pixels.pixels[pixelIndex - u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + image_size.width] >= uniforms.peak_value\n        );\n        var neighbor_valleys : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex - u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + image_size.width] <= uniforms.valley_value\n        ); \n        if (any(neighbor_peaks) && value < uniforms.peak_value) {\n            return vec4<f32>(0.8, 0.5, 0.5, 1.0);\n        }\n        if (any(neighbor_valleys) && value > uniforms.valley_value) {\n            return vec4<f32>(0.5, 0.3, 0.3, 1.0);\n        }\n    }\n    var color : vec4<f32> = textureLoad(myTexture, vec2<i32>(i32(value * 180.0), 1), 0);\n    return color;\n}`;\nexport const  display_3d_vert = `// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] vray_dir: vec3<f32>;\n  [[location(1), interpolate(flat)]] transformed_eye: vec3<f32>;\n};\n[[block]] struct Uniforms {\n  proj_view : mat4x4<f32>;\n  eye_pos : vec4<f32>;\n};\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec3<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    var volume_translation : vec3<f32> = vec3<f32>(-0.5, -0.5, -0.5);\n    output.Position = uniforms.proj_view * vec4<f32>(position + volume_translation, 1.0);\n    output.transformed_eye = uniforms.eye_pos.xyz - volume_translation;\n    output.vray_dir = position - output.transformed_eye;\n    return output;\n}`;\nexport const  display_3d_frag = `// Fragment shader\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(1)]] var colormap: texture_2d<f32>;\n[[group(0), binding(2)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn intersect_box(orig : vec3<f32>, dir : vec3<f32>, box_min : vec3<f32>, box_max : vec3<f32>) -> vec2<f32> {\n    let inv_dir : vec3<f32> = 1.0 / dir;\n    let tmin_tmp : vec3<f32> = (box_min - orig) * inv_dir;\n    let tmax_tmp : vec3<f32> = (box_max - orig) * inv_dir;\n    var tmin : vec3<f32> = min(tmin_tmp, tmax_tmp);\n    var tmax : vec3<f32> = max(tmin_tmp, tmax_tmp);\n    var t0 : f32 = max(tmin.x, max(tmin.y, tmin.z));\n    var t1 : f32 = min(tmax.x, min(tmax.y, tmax.z));\n    return vec2<f32>(t0, t1);\n}\n\nfn outside_grid(p : vec3<f32>, volumeDims : vec3<f32>) -> bool {\n    return any(p < vec3<f32>(0.0)) || any(p >= volumeDims);\n}\n\n[[stage(fragment)]]\nfn main(\n  [[location(0)]] vray_dir: vec3<f32>, \n  [[location(1), interpolate(flat)]] transformed_eye : vec3<f32>\n)-> [[location(0)]] vec4<f32> {\n    var ray_dir : vec3<f32> = normalize(vray_dir);\n    var longest_axis : f32 = f32(max(image_size.width, image_size.height));\n    let volume_dims : vec3<f32> = vec3<f32>(f32(image_size.width), f32(image_size.height), f32(longest_axis));\n    let vol_eye : vec3<f32> = transformed_eye * volume_dims;\n    let grid_ray_dir : vec3<f32> = normalize(ray_dir * volume_dims);\n\n    var t_hit : vec2<f32> = intersect_box(vol_eye, grid_ray_dir, vec3<f32>(0.0), volume_dims - 1.0);\n    if (t_hit.x > t_hit.y) { \n        discard;\n    }\n\n    t_hit.x = max(t_hit.x, 0.0);\n\n    var p : vec3<f32> = (vol_eye + t_hit.x * grid_ray_dir);\n    p = clamp(p, vec3<f32>(0.0), volume_dims - 2.0);\n    let inv_grid_ray_dir : vec3<f32> = 1.0 / grid_ray_dir;\n    let start_cell : vec3<f32> = floor(p);\n    let t_max_neg : vec3<f32> = (start_cell - vol_eye) * inv_grid_ray_dir;\n    let t_max_pos : vec3<f32> = (start_cell + 1.0 - vol_eye) * inv_grid_ray_dir;\n    let is_neg_dir : vec3<f32> = vec3<f32>(grid_ray_dir < vec3<f32>(0.0));\n    // Pick between positive/negative t_max based on the ray sign\n    var t_max : vec3<f32> = mix(t_max_pos, t_max_neg, is_neg_dir);\n    let grid_step : vec3<i32> = vec3<i32>(sign(grid_ray_dir));\n    // Note: each voxel is a 1^3 box on the grid\n    let t_delta : vec3<f32> = abs(inv_grid_ray_dir);\n\n    var t_prev : f32 = t_hit.x;\n    // Traverse the grid\n    loop {\n        if (outside_grid(p, volume_dims)) { break; }\n        let v000 : vec3<u32> = vec3<u32>(p);\n        var pixel_index : u32 = v000.x + v000.y * image_size.width;\n        var value : f32 = pixels.pixels[pixel_index];\n        if (f32(v000.z) > longest_axis / 2.0) {\n            if (value * longest_axis >= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } elseif (f32(v000.z) < longest_axis / 2.0) {\n            if (value * longest_axis <= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } else {\n            return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n        }\n\n        let t_next : f32 = min(t_max.x, min(t_max.y, t_max.z));\n        t_prev = t_next;\n        if (t_next == t_max.x) {\n            p.x = p.x + f32(grid_step.x);\n            t_max.x = t_max.x + t_delta.x;\n        } elseif (t_next == t_max.y) {\n            p.y = p.y + f32(grid_step.y);\n            t_max.y = t_max.y + t_delta.y;\n        } else {\n            p.z = p.z + f32(grid_step.z);\n            t_max.z = t_max.z + t_delta.z;\n        }\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n}\n\n`;\nexport const  node_vert = `// Vertex shader\nstruct VertexOutput {\n    [[builtin(position)]] Position : vec4<f32>;\n    [[location(0)]] position: vec2<f32>;\n    [[location(1), interpolate(flat)]] center : vec2<f32>;\n};\n[[block]] struct Uniforms {\n  view_box : vec4<f32>;\n};\n\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec2<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\n    var x : f32 = (position.x - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\n    var y : f32 = (position.y - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\n    output.Position = vec4<f32>(x, y, 0.0, 1.0);\n    output.position = position;\n    // flat interpolated position will give bottom right corner, so translate to center\n    output.center = output.position + vec2<f32>(-0.01, 0.01);\n    return output;\n}`;\nexport const  node_frag = `[[stage(fragment)]]\nfn main([[location(0)]] position: vec2<f32>, [[location(1), interpolate(flat)]] center: vec2<f32>) -> [[location(0)]] vec4<f32> {\n    if (distance(position, center) > 0.005) {\n        discard;\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n}\n`;\n","import { Controller } from './ez_canvas_controller';\nimport TerrainGenerator from './terrain_generator';\nimport { display_2d_vert, display_2d_frag, node_vert, node_frag } from './wgsl';\n\nclass Renderer {\n  public uniform2DBuffer : GPUBuffer | null = null;\n  public terrainGenerator : TerrainGenerator | null = null;\n  public device : GPUDevice;\n  public bindGroup2D : GPUBindGroup | null = null;\n  public nodeBindGroup : GPUBindGroup | null = null;\n  public nodePositionBuffer : GPUBuffer | null = null;\n  public nodePipeline : GPURenderPipeline | null = null;\n  public nodeLength : number = 1;\n  public rangeBuffer : GPUBuffer | null = null;\n\n  constructor(adapter : GPUAdapter, device : GPUDevice, canvasRef : React.RefObject<HTMLCanvasElement>, colormap : ImageBitmap) {\n    this.device = device;\n    // Check that canvas is active\n    if (canvasRef.current === null) return;\n    const context = canvasRef.current.getContext('webgpu')!;\n  \n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const presentationSize = [\n      canvasRef.current.clientWidth * devicePixelRatio,\n      canvasRef.current.clientHeight * devicePixelRatio,\n    ];\n    const presentationFormat = context.getPreferredFormat(adapter);\n  \n    context.configure({\n      device,\n      format: presentationFormat,\n      size: presentationSize,\n    });\n\n    this.rangeBuffer = this.device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    this.nodePositionBuffer = device.createBuffer({\n      size: 6 * 2 * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(this.nodePositionBuffer.getMappedRange()).set([\n      1, -1,\n      -1, -1,\n      -1, 1,\n      1, -1,\n      -1, 1,\n      1, 1,\n    ]);\n    this.nodePositionBuffer.unmap();\n\n    this.nodePipeline = device.createRenderPipeline({\n      vertex: {\n        module: device.createShaderModule({\n          code: node_vert,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: 2 * 4,\n            attributes: [\n              {\n                format: \"float32x2\" as GPUVertexFormat,\n                offset: 0,\n                shaderLocation: 0,\n              }\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: node_frag,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: 'triangle-list',\n      },\n      depthStencil: {\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: true,\n        depthCompare: \"less\",\n      }\n    });\n  \n    const pipeline = device.createRenderPipeline({\n      vertex: {\n        module: device.createShaderModule({\n          code: display_2d_vert,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: 4 * 4,\n            attributes: [\n              {\n                format: \"float32x4\" as GPUVertexFormat,\n                offset: 0,\n                shaderLocation: 0,\n              }\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: display_2d_frag,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: 'triangle-list',\n      },\n      depthStencil: {\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: true,\n        depthCompare: \"less\",\n      },\n    });\n\n    // Vertices to render\n    var dataBuf2D = device.createBuffer({\n      size: 6 * 4 * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(dataBuf2D.getMappedRange()).set([\n      1, -1, 0, 1,  // position\n      -1, -1, 0, 1, // position\n      -1, 1, 0, 1,   // position\n      1, -1, 0, 1,  // position\n      -1, 1, 0, 1, // position\n      1, 1, 0, 1,   // position\n    ]);\n    dataBuf2D.unmap();\n\n    // Set up uniform buffers for bind group\n    this.uniform2DBuffer = device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(this.uniform2DBuffer, 0, new Float32Array([0.8, 0.2]), 0, 2);\n    const imageSizeBuffer = device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.UNIFORM,\n      mappedAtCreation: true\n    });\n    new Uint32Array(imageSizeBuffer.getMappedRange()).set(presentationSize);\n    imageSizeBuffer.unmap();\n    const nodeDataBuffer = device.createBuffer({\n      size: 16,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    // Load colormap texture\n    const colorTexture = device.createTexture({\n      size: [colormap.width, colormap.height, 1],\n      format: \"rgba8unorm\",\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: colormap },\n      { texture: colorTexture },\n      [colormap.width, colormap.height, 1]\n    );\n\n    // Create depth texture\n    var depthTexture = device.createTexture({\n      size: {\n        width: presentationSize[0],\n        height: presentationSize[1],\n        depthOrArrayLayers: 1,\n      },\n      format: \"depth24plus-stencil8\",\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    this.terrainGenerator = new TerrainGenerator(device, presentationSize[0], presentationSize[1]);\n\n    this.bindGroup2D = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: colorTexture.createView(),\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: this.terrainGenerator.pixelValueBuffer,\n          }\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: this.uniform2DBuffer,\n          },\n        },\n        {\n          binding: 3,\n          resource: {\n            buffer: imageSizeBuffer,\n          }\n        }\n      ],\n    });\n    // this.nodeBindGroup = device.createBindGroup({\n    //   layout: pipeline.getBindGroupLayout(1),\n    //   entries: [\n    //     {\n    //       binding: 0,\n    //       resource: {\n    //         buffer: nodeDataBuffer,\n    //       }\n    //     }\n    //   ]\n    // });\n    var viewBoxBuffer = device.createBuffer({\n      size: 4 * 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array([0, 0, 1, 1]), 0, 4);\n    var translation = [0, 0, 1, 1];\n    var newTranslation = [0, 0, 1, 1];\n    var controller = new Controller();\n    var terrainGenerator = this.terrainGenerator;\n    var render = this;\n    controller.mousemove = function (prev, cur, evt) {\n      if (evt.buttons == 1) {\n        var change = [(cur[0] - prev[0]) / presentationSize[0], (prev[1] - cur[1]) / presentationSize[1]];\n        newTranslation = [newTranslation[0] - change[0], newTranslation[1] - change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]]\n        if (Math.abs(newTranslation[0] - translation[0]) > 0.03 || Math.abs(newTranslation[1] - translation[1]) > 0.03) {\n          translation = newTranslation;\n          terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer);\n          device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array(translation), 0, 4);\n        }\n      }\n    };\n    var zoom = 1;\n    controller.wheel = function (amt) {\n      var change = [amt / 1000, amt / 1000];\n      newTranslation = [newTranslation[0] + change[0], newTranslation[1] + change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]];\n      if (newTranslation[2] - newTranslation[0] > 0.1 && newTranslation[3] - newTranslation[1] > 0.1) {\n        translation = newTranslation;\n        terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer);\n        device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array(translation), 0, 4);\n      } else {\n        newTranslation = translation;\n      }\n    };\n    controller.registerForCanvas(canvasRef.current);\n    var viewBoxBindGroup = device.createBindGroup({\n      layout: this.nodePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: viewBoxBuffer,\n          },\n        },\n      ],\n    });\n\n    var render = this;\n    function frame() {\n        // Sample is no longer the active page.\n        if (!canvasRef.current) return;\n\n        const commandEncoder = device.createCommandEncoder();\n        const textureView = context.getCurrentTexture().createView();\n\n        const renderPassDescriptor: GPURenderPassDescriptor = {\n        colorAttachments: [\n          {\n            view: textureView,\n            loadValue: { r: 0.157, g: 0.173, b: 0.204, a: 1.0 },\n            storeOp: \"store\" as GPUStoreOp,\n          },\n        ],\n        depthStencilAttachment: {\n          view: depthTexture.createView(),\n          depthLoadValue: 1.0,\n          depthStoreOp: \"store\",\n          stencilLoadValue: 0,\n          stencilStoreOp: \"store\",\n        },\n        };\n\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(render.nodePipeline!);\n        passEncoder.setVertexBuffer(0, render.nodePositionBuffer!);\n        passEncoder.setBindGroup(0, viewBoxBindGroup);\n        passEncoder.draw(render.nodeLength * 6, 1, 0, 0);\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setVertexBuffer(0, dataBuf2D);\n        passEncoder.setBindGroup(0, render.bindGroup2D!);\n        passEncoder.draw(6, 1, 0, 0);\n        passEncoder.endPass();\n  \n        device.queue.submit([commandEncoder.finish()]);\n        requestAnimationFrame(frame);\n    }\n\n    requestAnimationFrame(frame);\n\n  }\n\n  setNodeData(nodeData : Array<number>) {\n    // TODO: Implement the translation and global range options\n    this.terrainGenerator!.computeTerrain(nodeData, undefined, undefined, this.rangeBuffer);\n    var nodePositions : Array<number> = [];\n    var radius : number = 0.01;\n    for (var i = 0; i < nodeData.length; i+=4) {\n      var x = nodeData[i+1] * 2 - 1;\n      var y = nodeData[i+2] * 2 - 1;\n      nodePositions.push(\n        x + radius, y - radius,\n        x - radius, y - radius,\n        x - radius, y + radius,\n        x + radius, y - radius,\n        x - radius, y + radius,\n        x + radius, y + radius\n      );\n    }\n    this.nodePositionBuffer = this.device.createBuffer({\n      size: nodePositions.length * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(this.nodePositionBuffer.getMappedRange()).set(nodePositions);\n    this.nodePositionBuffer.unmap();\n    this.nodeLength = nodeData.length / 4;\n\n    // this.nodeBindGroup = this.device.createBindGroup({\n    //   layout: this.nodePipeline!.getBindGroupLayout(1),\n    //   entries: [\n    //     {\n    //       binding: 0,\n    //       resource: {\n    //         buffer: this.terrainGenerator!.nodeDataBuffer,\n    //       }\n    //     }\n    //   ]\n    // });\n  }\n\n  setWidthFactor(widthFactor : number) {\n    this.terrainGenerator!.computeTerrain(undefined, widthFactor, undefined, this.rangeBuffer);\n  }\n\n  setPeakValue(value : number) {\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 0, new Float32Array([value]), 0, 1);\n  }\n\n  setValleyValue(value : number) {\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 4, new Float32Array([value]), 0, 1);\n  }\n\n  setGlobalRange() {\n    if (this.rangeBuffer) {\n      this.rangeBuffer = null;\n    } else {\n      this.rangeBuffer = this.device.createBuffer({\n        size: 2 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });    \n    }\n  }\n}\nexport default Renderer;\n\n","import React from 'react';\nimport Sidebar from './Sidebar';\nimport { createRef, MutableRefObject } from 'react';\nimport Renderer from \"../webgpu/render\";\nimport colormap from './rainbow.png';\n\ntype PageState = {\n    widthFactor: number,\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    renderer: Renderer | null,\n}\nclass Page extends React.Component<{}, PageState> {\n    constructor(props) {\n        super(props);\n        this.state = {widthFactor: 1000, canvasRef: createRef<HTMLCanvasElement | null>(), renderer: null};\n    }\n\n    async componentDidMount() {\n        const adapter = (await navigator.gpu.requestAdapter())!;\n        const device = await adapter.requestDevice(); \n        var colormapImage = new Image();\n        colormapImage.src = colormap;\n        await colormapImage.decode();\n        const imageBitmap = await createImageBitmap(colormapImage);\n        this.setState({renderer: new Renderer(adapter, device, this.state.canvasRef, imageBitmap)});\n    }\n\n    setNodeData(nodeData : Array<number>) {\n        this.state.renderer!.setNodeData(nodeData);\n    }\n\n    setWidthFactor(widthFactor : number) {\n        this.state.renderer!.setWidthFactor(widthFactor);\n    }\n\n    setPeakValue(value : number) {\n        this.state.renderer!.setPeakValue(value);\n    }\n\n    setValleyValue(value : number) {\n        this.state.renderer!.setValleyValue(value);\n    }\n\n    setGlobalRange() {\n        this.state.renderer!.setGlobalRange();\n    }\n  \n    render() {\n      return (\n        <div>\n            <Sidebar \n                setValleyValue={this.setValleyValue.bind(this)} \n                setPeakValue={this.setPeakValue.bind(this)} \n                setWidthFactor={this.setWidthFactor.bind(this)} \n                setNodeData={this.setNodeData.bind(this)} \n                setGlobalRange={this.setGlobalRange.bind(this)}\n            />\n            <div className=\"canvasContainer\">\n                <canvas ref={this.state.canvasRef} width={800} height={800}></canvas>\n            </div>\n        </div>\n      );\n    }\n  }\n\nexport default Page;","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAABCAYAAAB3yoT0AAAAOklEQVQokc3QsQrAIBBEwTEI+v9fG0E8e0kKu6se7HRbiFBR0X+azVpg4j36teWwx0px3Y2VkeK6K9uFnl0AGQ1BkQAAAABJRU5ErkJggg==\"","import './App.css';\nimport Page from './components/Page';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Page />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode >\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}