{"version":3,"sources":["components/Sidebar.tsx","webgpu/ez_canvas_controller.ts","webgpu/terrain_generator.ts","webgpu/wgsl.tsx","webgpu/render.tsx","components/Page.tsx","components/rainbow.png","App.tsx","index.tsx"],"names":["Sidebar","props","state","nodeData","handleSubmit","bind","readFiles","event","preventDefault","this","setNodeData","files","target","console","log","nodeIDToValue","edgeReader","FileReader","onload","layoutReader","layoutData","result","split","parts","push","parseFloat","setState","readAsText","nodeReader","rawNodes","element","className","Form","style","color","onSubmit","Group","controlId","Label","Control","type","multiple","onChange","Button","variant","value","trigger","defaultValue","min","max","e","setWidthFactor","step","setPeakValue","setValleyValue","Check","defaultChecked","onClick","setGlobalRange","label","toggleTerrainLayer","toggleNodeLayer","onSave","React","Component","Controller","mousemove","press","wheel","canvas","prevMouse","self","addEventListener","evt","rect","getBoundingClientRect","curMouse","clientX","left","clientY","top","deltaY","oncontextmenu","TerrainGenerator","device","width","height","rangeBuffer","pixelValueBuffer","paramsBuffer","nodeDataBuffer","computeTerrainPipeline","normalizeTerrainPipeline","computeTerrainBGLayout","normalizeTerrainBGLayout","createBuffer","size","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","storage","uniform","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","createComputePipeline","layout","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","UNIFORM","widthFactor","translation","globalRange","length","mappedAtCreation","Float32Array","getMappedRange","set","unmap","upload","mapping","Uint32Array","commandEncoder","createCommandEncoder","copyBufferToBuffer","bindGroup","createBindGroup","resource","pass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","Renderer","adapter","canvasRef","colormap","colormapImage","outCanvasRef","uniform2DBuffer","terrainGenerator","bindGroup2D","nodeBindGroup","nodePositionBuffer","nodePipeline","nodeLength","nodeToggle","terrainToggle","current","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","configure","format","VERTEX","createRenderPipeline","vertex","buffers","arrayStride","attributes","offset","shaderLocation","fragment","targets","blend","srcFactor","dstFactor","alpha","primitive","topology","multisample","count","pipeline","dataBuf2D","writeBuffer","imageSizeBuffer","colorTexture","createTexture","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","copyExternalImageToTexture","source","texture","getBindGroupLayout","createView","viewBoxBuffer","newTranslation","controller","render","prev","cur","buttons","change","Math","abs","computeTerrain","undefined","amt","registerForCanvas","viewBoxBindGroup","view","sampleCount","requestAnimationFrame","frame","renderPassDescriptor","colorAttachments","resolveTarget","getCurrentTexture","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setVertexBuffer","draw","nodePositions","radius","i","x","y","gpuReadBuffer","MAP_READ","gpuCommands","mapAsync","GPUMapMode","READ","arrayBuffer","output","drawImage","colorData","getImageData","data","imgData","createImageData","j","index","colorIndex","trunc","putImageData","toBlob","saveAs","Page","createRef","renderer","navigator","gpu","requestAdapter","requestDevice","Image","src","decode","createImageBitmap","imageBitmap","ref","hidden","App","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.44fd6d0f.chunk.js","sourcesContent":["import React from 'react';\nimport {Form, Button} from \"react-bootstrap\";\nimport Collapsible from 'react-collapsible';\n\ntype SidebarProps = {\n  setNodeData: (nodeData : Array<number>) => void,\n  setWidthFactor: (widthFactor : number) => void,\n  setPeakValue: (value : number) => void,\n  setValleyValue: (value : number) => void,\n  setGlobalRange: () => void,\n  toggleNodeLayer: () => void,\n  toggleTerrainLayer: () => void,\n  onSave: () => void,\n}\ntype SidebarState = {\n  nodeData: Array<number>\n}\nclass Sidebar extends React.Component<SidebarProps, SidebarState> {\n    constructor(props) {\n      super(props);\n      this.state = {nodeData: []};\n  \n      this.handleSubmit = this.handleSubmit.bind(this);\n      this.readFiles = this.readFiles.bind(this);\n    }\n  \n    handleSubmit(event) {\n      event.preventDefault();\n      this.props.setNodeData(this.state.nodeData);\n    }\n\n    readFiles(event : React.ChangeEvent<HTMLInputElement>) {\n        const files : FileList = event.target.files!;\n        console.log(files);\n        var nodeIDToValue = {};\n        var nodeData : Array<number> = [];\n        const edgeReader = new FileReader();\n        edgeReader.onload = (event) => {\n        //   var edgeData = (edgeReader.result as string).split(\"\\n\");\n        //   for (var element of edgeData) {\n        //     var parts = element.split(\"\\t\");\n        //     if (nodeIDToValue[parts[0]] && nodeIDToValue[parts[1]]) {\n        //       nodeElements.push({ data: { source: parts[0], target: parts[1], weight: parseFloat(parts[2]) } });\n        //     }\n        //   }\n        //   await render(nodeData, index);\n            console.log(\"not yet implemented edges\");\n        };\n        const layoutReader = new FileReader();\n        layoutReader.onload = (event) => {\n          var layoutData = (layoutReader.result as string).split(\"\\n\");\n          for (var element of layoutData) {\n            var parts = element.split(\"\\t\");\n            if (nodeIDToValue[parts[0]]) {\n              // Pushes values to node data in order of struct for WebGPU:\n              // nodeValue, nodeX, nodeY, nodeSize\n              nodeData.push(parseFloat(nodeIDToValue[parts[0]]), parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));\n            }\n          }\n          this.setState({nodeData: nodeData});\n          edgeReader.readAsText(files[1]);\n        };\n        const nodeReader = new FileReader();\n        nodeReader.onload = (event) => {\n          var rawNodes = (nodeReader.result as string).split(\"\\n\");\n          for (var element of rawNodes) {\n            nodeIDToValue[element.split(\"\\t\")[0]] = element.split(\"\\t\")[1]\n          }\n          layoutReader.readAsText(files[1]);\n        };\n        nodeReader.readAsText(files[0]);\n    }\n  \n    render() {\n      return (\n        <div className=\"sidebar\"> \n        <Form style={{color: 'white'}} onSubmit={this.handleSubmit}>\n          <Form.Group controlId=\"formFile\" className=\"mt-3 mb-3\">\n            <Form.Label>Select Example Files</Form.Label>\n            <Form.Control className=\"form-control\" type=\"file\" multiple onChange={this.readFiles}/>\n            <Button className=\"mt-2\" type=\"submit\" variant=\"secondary\" value=\"Submit\">Submit</ Button>\n          </Form.Group>\n          <Collapsible trigger=\"Terrain Options\">\n            <Form.Group> \n              <Form.Label> Width Factor </ Form.Label>\n              <br/>\n              <input type=\"range\" defaultValue={1000} min={0} max={2000} onChange={(e) => this.props.setWidthFactor(parseFloat(e.target.value))} />\n            </Form.Group>\n            <Form.Group> \n              <Form.Label> Peak and Valley Values </ Form.Label>\n              <br/>\n              <input type=\"range\" defaultValue={0.8} min={0.5} max={1} step={0.01} onChange={(e) => this.props.setPeakValue(parseFloat(e.target.value))} />\n              <input type=\"range\" defaultValue={0.2} min={0} max={0.5} step={0.01} onChange={(e) => this.props.setValleyValue(parseFloat(e.target.value))} />\n            </Form.Group>\n            <Form.Group>\n              <Form.Check defaultChecked={true} onClick={(e) => this.props.setGlobalRange()} type=\"checkbox\" label=\"Use Global Min/Max\"></Form.Check>\n            </Form.Group>\n          </Collapsible>\n          <Collapsible trigger=\"Layers\"> \n            <Form.Check defaultChecked={false} onClick={(e) => this.props.toggleTerrainLayer()} type=\"checkbox\" label=\"Terrain Layer\"/>\n            <Form.Check defaultChecked={true} onClick={(e) => this.props.toggleNodeLayer()} type=\"checkbox\" label=\"Node Layer\"/>\n          </Collapsible>\n          <Button onClick={(e) => this.props.onSave()}>\n            Save Terrain\n          </Button>\n        </Form>\n        </ div>\n      );\n    }\n  }\n\nexport default Sidebar;","/* The controller can register callbacks for various events on a canvas:\n *\n * mousemove: function(prevMouse, curMouse, evt)\n *     receives both regular mouse events, and single-finger drags (sent as a left-click),\n *\n * press: function(curMouse, evt)\n *     receives mouse click and touch start events\n *\n * wheel: function(amount)\n *     mouse wheel scrolling\n */\nexport class Controller {\n    public mousemove : ((prevMouse : number[], curMouse : number[], evt : MouseEvent) => void) | null;\n    public press : ((curMouse : number[], evt : MouseEvent) => void) | null;\n    public wheel : ((amount : number) => void) | null;\n\n    constructor()\n    {\n        this.mousemove = null;\n        this.press = null;\n        this.wheel = null;\n    }\n\n    registerForCanvas(canvas : HTMLCanvasElement)\n    {\n        var prevMouse : number[] | null = null;\n        var self = this;\n        canvas.addEventListener(\"mousemove\", function(evt : MouseEvent) {\n            evt.preventDefault();\n            var rect = canvas.getBoundingClientRect();\n            var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            if (!prevMouse) {\n                prevMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            } else if (self.mousemove) {\n                self.mousemove(prevMouse, curMouse, evt);\n            }\n            prevMouse = curMouse;\n        });\n\n        canvas.addEventListener(\"mousedown\", function(evt : MouseEvent) {\n            evt.preventDefault();\n            var rect = canvas.getBoundingClientRect();\n            var curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\n            if (self.press) {\n                self.press(curMouse, evt);\n            }\n        });\n\n        canvas.addEventListener(\"wheel\", function(evt) {\n            evt.preventDefault();\n            if (self.wheel) {\n                self.wheel(-evt.deltaY);\n            }\n        });\n\n        canvas.oncontextmenu = function(evt) {\n            evt.preventDefault();\n        };\n    }\n}\n\n","import { compute_terrain, normalize_terrain } from './wgsl';\n\nclass TerrainGenerator {\n    public rangeBuffer : GPUBuffer;\n    public pixelValueBuffer : GPUBuffer;\n    public paramsBuffer : GPUBuffer;\n    public nodeDataBuffer : GPUBuffer;\n    public device : GPUDevice;\n    public width : number;\n    public height : number;\n    public computeTerrainPipeline : GPUComputePipeline;\n    public normalizeTerrainPipeline : GPUComputePipeline;\n    public computeTerrainBGLayout : GPUBindGroupLayout;\n    public normalizeTerrainBGLayout : GPUBindGroupLayout;\n    public nodeData : Array<number> = [];\n    \n    constructor(device : GPUDevice, width, height) {\n        this.device = device;\n        this.width = width;\n        this.height = height;\n\n        this.nodeDataBuffer = this.device.createBuffer({\n            size: 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.rangeBuffer = this.device.createBuffer({\n            size: 2 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        });\n\n        var storage : GPUBufferBindingType = \"storage\";\n        var uniform : GPUBufferBindingType = \"uniform\";\n        this.computeTerrainBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: uniform,\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                }\n            ],\n        });\n\n        this.computeTerrainPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [this.computeTerrainBGLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: compute_terrain,\n                }),\n                entryPoint: \"main\",\n            },\n        });\n\n        this.normalizeTerrainBGLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: uniform,\n                    }\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: storage,\n                    }\n                }\n            ],\n        });\n\n        this.normalizeTerrainPipeline = device.createComputePipeline({\n            layout: device.createPipelineLayout({\n                bindGroupLayouts: [this.normalizeTerrainBGLayout],\n            }),\n            compute: {\n                module: device.createShaderModule({\n                    code: normalize_terrain,\n                }),\n                entryPoint: \"main\",\n            },\n        });\n\n        // Create a buffer to store the params, output, and min/max\n        this.paramsBuffer = device.createBuffer({\n            size: 8 * 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.pixelValueBuffer = device.createBuffer({\n            size: this.width * this.height * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        });\n    }\n\n    computeTerrain(nodeData = this.nodeData, widthFactor = 1000, translation = [0, 0, 1, 1], globalRange : null | GPUBuffer = null) {\n        if (nodeData.length == 0) {\n            return;\n        }\n        this.nodeData = nodeData;\n        // Set up node data buffer\n        this.nodeDataBuffer = this.device.createBuffer({\n            size: nodeData.length * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            mappedAtCreation: true,\n        });\n        new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\n        this.nodeDataBuffer.unmap();\n\n        // Have to reset range buffer unless global range checked\n        if (!globalRange) {\n            this.rangeBuffer = this.device.createBuffer({\n                size: 2 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            });\n        } else {\n            this.rangeBuffer = globalRange;\n        }\n\n        // Set up params (image width, height, node length, and width factor)\n        var upload = this.device.createBuffer({\n            size: 8 * 4,\n            usage: GPUBufferUsage.COPY_SRC,\n            mappedAtCreation: true,\n        });\n        var mapping = upload.getMappedRange();\n        new Uint32Array(mapping).set([this.width, this.height, nodeData.length / 4]);\n        new Float32Array(mapping).set([widthFactor, translation[0], translation[1], translation[2], translation[3]], 3);\n        upload.unmap();\n        //this.device.createQuerySet({})\n        var commandEncoder = this.device.createCommandEncoder();\n        //commandEncoder.writeTimestamp();\n        commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 8 * 4);\n        // Create bind group\n        var bindGroup = this.device.createBindGroup({\n            layout: this.computeTerrainBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.nodeDataBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.paramsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.pixelValueBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: this.rangeBuffer,\n                    },\n                },\n            ],\n        });\n\n        // Run compute terrain pass\n        var pass = commandEncoder.beginComputePass();\n        pass.setBindGroup(0, bindGroup);\n        pass.setPipeline(this.computeTerrainPipeline);\n        pass.dispatch(this.width, this.height, 1);\n        //commandEncoder.writeTimestamp();\n        // await this.device.queue.onSubmittedWorkDone();\n\n        // Look into submitting normalization and compute in one pass to improve speed, remove synchronizations\n        // Use writetimestamp for more accurate kernel timing\n\n        // Run normalize terrain pass\n        var bindGroup = this.device.createBindGroup({\n            layout: this.normalizeTerrainBGLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.pixelValueBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.paramsBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.rangeBuffer,\n                    },\n                },\n            ],\n        });\n        pass.setBindGroup(0, bindGroup);\n        pass.setPipeline(this.normalizeTerrainPipeline);\n        pass.dispatch(this.width, this.height, 1);\n        pass.endPass();\n        this.device.queue.submit([commandEncoder.finish()]);\n        // await this.device.queue.onSubmittedWorkDone();\n    }\n}\n\nexport default TerrainGenerator;","export const  compute_terrain = `// compute terrain wgsl\nstruct Node {\n    value : f32;\n    x : f32;\n    y : f32;\n    size : f32;\n};\n[[block]] struct Nodes {\n    nodes : array<Node>;\n};\n[[block]] struct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n  view_box : vec4<f32>;\n};\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Range {\n    x : atomic<i32>;\n    y : atomic<i32>;\n};\n\n[[group(0), binding(0)]] var<storage, read> nodes : Nodes;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(3)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    var x : f32 = f32(global_id.x) / f32(uniforms.image_width);\n    var y : f32 = f32(global_id.y) / f32(uniforms.image_height);\n    x = x * (uniforms.view_box.z - uniforms.view_box.x) + uniforms.view_box.x;\n    y = y * (uniforms.view_box.w - uniforms.view_box.y) + uniforms.view_box.y;\n    var value : f32 = 0.0;\n\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\n        var sqrDistance : f32 = (x - nodes.nodes[i].x) * (x - nodes.nodes[i].x) + (y - nodes.nodes[i].y) * (y - nodes.nodes[i].y);\n        value = value + nodes.nodes[i].value / (sqrDistance * uniforms.width_factor + 1.0);\n    }\n    value = value * 100.0;\n    ignore(atomicMin(&range.x, i32(floor(value))));\n    ignore(atomicMax(&range.y, i32(ceil(value))));\n    pixels.pixels[pixel_index] = value;\n}`;\nexport const  normalize_terrain = `// normalize terrain wgsl\n[[block]] struct Uniforms {\n  image_width : u32;\n  image_height : u32;\n  nodes_length : u32;\n  width_factor : f32;\n};\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Range {\n    x : i32;\n    y : i32;\n};\n\n[[group(0), binding(0)]] var<storage, write> pixels : Pixels;\n[[group(0), binding(1)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(2)]] var<storage, read_write> range : Range;\n\n[[stage(compute), workgroup_size(1, 1, 1)]]\nfn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n    var pixel_index : u32 = global_id.x + global_id.y * uniforms.image_width;\n    pixels.pixels[pixel_index] = (pixels.pixels[pixel_index] - f32(range.x)) / f32(range.y - range.x);\n}`;\nexport const  display_2d_vert = `// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] fragPosition: vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec4<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    output.Position = position;\n    output.fragPosition = 0.5 * (position + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n    return output;\n}\n\n\n`;\nexport const  display_2d_frag = `// Fragment shader\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Uniforms {\n    peak_value : f32;\n    valley_value : f32;\n};\n[[block]] struct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(0)]] var myTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(2)]] var<uniform> uniforms : Uniforms;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn outside_grid(p : vec2<u32>) -> bool {\n    return any(p == vec2<u32>(u32(0))) || p.x == image_size.width || p.y == image_size.height;\n}\n\n[[stage(fragment)]]\nfn main([[location(0)]] fragPosition: vec4<f32>) -> [[location(0)]] vec4<f32> {\n    var ufragPos : vec4<u32> = vec4<u32>(fragPosition * f32(image_size.width));\n    var pixelIndex : u32 = ufragPos.x + ufragPos.y * image_size.width;\n    var value : f32 = pixels.pixels[pixelIndex];\n    if (!outside_grid(ufragPos.xy)){\n        var neighbor_peaks : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] >= uniforms.peak_value ,\n            pixels.pixels[pixelIndex - u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + u32(1)] >= uniforms.peak_value,\n            pixels.pixels[pixelIndex + image_size.width] >= uniforms.peak_value\n        );\n        var neighbor_valleys : vec4<bool> = vec4<bool>(\n            pixels.pixels[pixelIndex - image_size.width] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex - u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + u32(1)] <= uniforms.valley_value,\n            pixels.pixels[pixelIndex + image_size.width] <= uniforms.valley_value\n        ); \n        if (any(neighbor_peaks) && value < uniforms.peak_value) {\n            return vec4<f32>(0.8, 0.5, 0.5, 1.0);\n        }\n        if (any(neighbor_valleys) && value > uniforms.valley_value) {\n            return vec4<f32>(0.5, 0.3, 0.3, 1.0);\n        }\n    }\n    var color : vec4<f32> = textureLoad(myTexture, vec2<i32>(i32(value * 180.0), 1), 0);\n    return color;\n}`;\nexport const  display_3d_vert = `// Vertex shader\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] vray_dir: vec3<f32>;\n  [[location(1), interpolate(flat)]] transformed_eye: vec3<f32>;\n};\n[[block]] struct Uniforms {\n  proj_view : mat4x4<f32>;\n  eye_pos : vec4<f32>;\n};\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec3<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    var volume_translation : vec3<f32> = vec3<f32>(-0.5, -0.5, -0.5);\n    output.Position = uniforms.proj_view * vec4<f32>(position + volume_translation, 1.0);\n    output.transformed_eye = uniforms.eye_pos.xyz - volume_translation;\n    output.vray_dir = position - output.transformed_eye;\n    return output;\n}`;\nexport const  display_3d_frag = `// Fragment shader\n[[block]] struct Pixels {\n    pixels : array<f32>;\n};\n[[block]] struct Image {\n    width : u32;\n    height : u32;\n};\n\n[[group(0), binding(1)]] var colormap: texture_2d<f32>;\n[[group(0), binding(2)]] var<storage, read> pixels : Pixels;\n[[group(0), binding(3)]] var<uniform> image_size : Image;\n\nfn intersect_box(orig : vec3<f32>, dir : vec3<f32>, box_min : vec3<f32>, box_max : vec3<f32>) -> vec2<f32> {\n    let inv_dir : vec3<f32> = 1.0 / dir;\n    let tmin_tmp : vec3<f32> = (box_min - orig) * inv_dir;\n    let tmax_tmp : vec3<f32> = (box_max - orig) * inv_dir;\n    var tmin : vec3<f32> = min(tmin_tmp, tmax_tmp);\n    var tmax : vec3<f32> = max(tmin_tmp, tmax_tmp);\n    var t0 : f32 = max(tmin.x, max(tmin.y, tmin.z));\n    var t1 : f32 = min(tmax.x, min(tmax.y, tmax.z));\n    return vec2<f32>(t0, t1);\n}\n\nfn outside_grid(p : vec3<f32>, volumeDims : vec3<f32>) -> bool {\n    return any(p < vec3<f32>(0.0)) || any(p >= volumeDims);\n}\n\n[[stage(fragment)]]\nfn main(\n  [[location(0)]] vray_dir: vec3<f32>, \n  [[location(1), interpolate(flat)]] transformed_eye : vec3<f32>\n)-> [[location(0)]] vec4<f32> {\n    var ray_dir : vec3<f32> = normalize(vray_dir);\n    var longest_axis : f32 = f32(max(image_size.width, image_size.height));\n    let volume_dims : vec3<f32> = vec3<f32>(f32(image_size.width), f32(image_size.height), f32(longest_axis));\n    let vol_eye : vec3<f32> = transformed_eye * volume_dims;\n    let grid_ray_dir : vec3<f32> = normalize(ray_dir * volume_dims);\n\n    var t_hit : vec2<f32> = intersect_box(vol_eye, grid_ray_dir, vec3<f32>(0.0), volume_dims - 1.0);\n    if (t_hit.x > t_hit.y) { \n        discard;\n    }\n\n    t_hit.x = max(t_hit.x, 0.0);\n\n    var p : vec3<f32> = (vol_eye + t_hit.x * grid_ray_dir);\n    p = clamp(p, vec3<f32>(0.0), volume_dims - 2.0);\n    let inv_grid_ray_dir : vec3<f32> = 1.0 / grid_ray_dir;\n    let start_cell : vec3<f32> = floor(p);\n    let t_max_neg : vec3<f32> = (start_cell - vol_eye) * inv_grid_ray_dir;\n    let t_max_pos : vec3<f32> = (start_cell + 1.0 - vol_eye) * inv_grid_ray_dir;\n    let is_neg_dir : vec3<f32> = vec3<f32>(grid_ray_dir < vec3<f32>(0.0));\n    // Pick between positive/negative t_max based on the ray sign\n    var t_max : vec3<f32> = mix(t_max_pos, t_max_neg, is_neg_dir);\n    let grid_step : vec3<i32> = vec3<i32>(sign(grid_ray_dir));\n    // Note: each voxel is a 1^3 box on the grid\n    let t_delta : vec3<f32> = abs(inv_grid_ray_dir);\n\n    var t_prev : f32 = t_hit.x;\n    // Traverse the grid\n    loop {\n        if (outside_grid(p, volume_dims)) { break; }\n        let v000 : vec3<u32> = vec3<u32>(p);\n        var pixel_index : u32 = v000.x + v000.y * image_size.width;\n        var value : f32 = pixels.pixels[pixel_index];\n        if (f32(v000.z) > longest_axis / 2.0) {\n            if (value * longest_axis >= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } elseif (f32(v000.z) < longest_axis / 2.0) {\n            if (value * longest_axis <= f32(v000.z)) {\n                return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n            }\n        } else {\n            return textureLoad(colormap, vec2<i32>(i32(value * 180.0), 1), 0);\n        }\n\n        let t_next : f32 = min(t_max.x, min(t_max.y, t_max.z));\n        t_prev = t_next;\n        if (t_next == t_max.x) {\n            p.x = p.x + f32(grid_step.x);\n            t_max.x = t_max.x + t_delta.x;\n        } elseif (t_next == t_max.y) {\n            p.y = p.y + f32(grid_step.y);\n            t_max.y = t_max.y + t_delta.y;\n        } else {\n            p.z = p.z + f32(grid_step.z);\n            t_max.z = t_max.z + t_delta.z;\n        }\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n}\n\n`;\nexport const  node_vert = `// Vertex shader\nstruct VertexOutput {\n    [[builtin(position)]] Position : vec4<f32>;\n    [[location(0)]] position: vec2<f32>;\n    [[location(1), interpolate(flat)]] center : vec2<f32>;\n};\n[[block]] struct Uniforms {\n  view_box : vec4<f32>;\n};\n\n[[group(0), binding(0)]] var<uniform> uniforms : Uniforms;\n[[stage(vertex)]]\nfn main([[location(0)]] position : vec2<f32>)\n     -> VertexOutput {\n    var output : VertexOutput;\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\n    var x : f32 = (position.x - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\n    var y : f32 = (position.y - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\n    output.Position = vec4<f32>(x, y, 0.0, 1.0);\n    output.position = position;\n    // flat interpolated position will give bottom right corner, so translate to center\n    output.center = output.position + vec2<f32>(-0.01, 0.01);\n    return output;\n}`;\nexport const  node_frag = `fn sigmoid(x: f32) -> f32 {\n    return 1.0 / (1.0 + exp(-1.0 * x));\n}\n\n[[stage(fragment)]]\nfn main([[location(0)]] position: vec2<f32>, [[location(1), interpolate(flat)]] center: vec2<f32>) -> [[location(0)]] vec4<f32> {\n    if (distance(position, center) > 0.005) {\n        discard;\n    }\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0 - sigmoid(16.0 * distance(position, center) * 200.0 - 12.0));\n}\n`;\n","import { Controller } from './ez_canvas_controller';\nimport TerrainGenerator from './terrain_generator';\nimport { display_2d_vert, display_2d_frag, node_vert, node_frag } from './wgsl';\nimport { saveAs } from 'file-saver'; \n\nclass Renderer {\n  public uniform2DBuffer : GPUBuffer | null = null;\n  public terrainGenerator : TerrainGenerator | null = null;\n  public device : GPUDevice;\n  public bindGroup2D : GPUBindGroup | null = null;\n  public nodeBindGroup : GPUBindGroup | null = null;\n  public nodePositionBuffer : GPUBuffer | null = null;\n  public nodePipeline : GPURenderPipeline | null = null;\n  public nodeLength : number = 1;\n  public rangeBuffer : GPUBuffer | null = null;\n  public nodeToggle : boolean = true;\n  public terrainToggle : boolean = false;\n  public colormapImage : HTMLImageElement;\n  public outCanvasRef : React.RefObject<HTMLCanvasElement>;\n\n  constructor(\n    adapter : GPUAdapter, device : GPUDevice, \n    canvasRef : React.RefObject<HTMLCanvasElement>, \n    colormap : ImageBitmap, colormapImage : HTMLImageElement,\n    outCanvasRef : React.RefObject<HTMLCanvasElement>, \n  ) {\n    this.colormapImage = colormapImage;\n    this.outCanvasRef = outCanvasRef\n    this.device = device;\n    // Check that canvas is active\n    if (canvasRef.current === null) return;\n    const context = canvasRef.current.getContext('webgpu')!;\n  \n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const presentationSize = [\n      canvasRef.current.clientWidth * devicePixelRatio,\n      canvasRef.current.clientHeight * devicePixelRatio,\n    ];\n    const presentationFormat = context.getPreferredFormat(adapter);\n  \n    context.configure({\n      device,\n      format: presentationFormat,\n      size: presentationSize,\n    });\n\n    this.rangeBuffer = this.device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    });\n\n    this.nodePositionBuffer = device.createBuffer({\n      size: 6 * 2 * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(this.nodePositionBuffer.getMappedRange()).set([\n      1, -1,\n      -1, -1,\n      -1, 1,\n      1, -1,\n      -1, 1,\n      1, 1,\n    ]);\n    this.nodePositionBuffer.unmap();\n\n    this.nodePipeline = device.createRenderPipeline({\n      vertex: {\n        module: device.createShaderModule({\n          code: node_vert,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: 2 * 4,\n            attributes: [\n              {\n                format: \"float32x2\" as GPUVertexFormat,\n                offset: 0,\n                shaderLocation: 0,\n              }\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: node_frag,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n            blend: {\n              color: {srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor},\n              alpha: {srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor}\n            },\n          },\n        ],\n      },\n      primitive: {\n        topology: 'triangle-list',\n      },\n      multisample: {\n        count: 4\n      }\n    });\n  \n    const pipeline = device.createRenderPipeline({\n      vertex: {\n        module: device.createShaderModule({\n          code: display_2d_vert,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: 4 * 4,\n            attributes: [\n              {\n                format: \"float32x4\" as GPUVertexFormat,\n                offset: 0,\n                shaderLocation: 0,\n              }\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: device.createShaderModule({\n          code: display_2d_frag,\n        }),\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n          },\n        ],\n      },\n      primitive: {\n        topology: 'triangle-list',\n      },\n      multisample: {\n        count: 4\n      }\n    });\n\n    // Vertices to render\n    var dataBuf2D = device.createBuffer({\n      size: 6 * 4 * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(dataBuf2D.getMappedRange()).set([\n      1, -1, 0, 1,  // position\n      -1, -1, 0, 1, // position\n      -1, 1, 0, 1,   // position\n      1, -1, 0, 1,  // position\n      -1, 1, 0, 1, // position\n      1, 1, 0, 1,   // position\n    ]);\n    dataBuf2D.unmap();\n\n    // Set up uniform buffers for bind group\n    this.uniform2DBuffer = device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(this.uniform2DBuffer, 0, new Float32Array([0.8, 0.2]), 0, 2);\n    const imageSizeBuffer = device.createBuffer({\n      size: 2 * 4,\n      usage: GPUBufferUsage.UNIFORM,\n      mappedAtCreation: true\n    });\n    new Uint32Array(imageSizeBuffer.getMappedRange()).set([800, 800]);\n    imageSizeBuffer.unmap();\n    const nodeDataBuffer = device.createBuffer({\n      size: 16,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n\n    // Load colormap texture\n    const colorTexture = device.createTexture({\n      size: [colormap.width, colormap.height, 1],\n      format: \"rgba8unorm\",\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    device.queue.copyExternalImageToTexture(\n      { source: colormap },\n      { texture: colorTexture },\n      [colormap.width, colormap.height, 1]\n    );\n\n    this.terrainGenerator = new TerrainGenerator(device, 800, 800);\n\n    this.bindGroup2D = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: colorTexture.createView(),\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: this.terrainGenerator.pixelValueBuffer,\n          }\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: this.uniform2DBuffer,\n          },\n        },\n        {\n          binding: 3,\n          resource: {\n            buffer: imageSizeBuffer,\n          }\n        }\n      ],\n    });\n    // this.nodeBindGroup = device.createBindGroup({\n    //   layout: pipeline.getBindGroupLayout(1),\n    //   entries: [\n    //     {\n    //       binding: 0,\n    //       resource: {\n    //         buffer: nodeDataBuffer,\n    //       }\n    //     }\n    //   ]\n    // });\n    var viewBoxBuffer = device.createBuffer({\n      size: 4 * 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array([0, 0, 1, 1]), 0, 4);\n    var translation = [0, 0, 1, 1];\n    var newTranslation = [0, 0, 1, 1];\n    var controller = new Controller();\n    var terrainGenerator = this.terrainGenerator;\n    var render = this;\n    controller.mousemove = function (prev, cur, evt) {\n      if (evt.buttons == 1) {\n        var change = [(cur[0] - prev[0]) * (translation[2] - translation[0]) / 800, (prev[1] - cur[1]) * (translation[3] - translation[1]) / 800];\n        newTranslation = [newTranslation[0] - change[0], newTranslation[1] - change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]]\n        if (Math.abs(newTranslation[0] - translation[0]) > 0.03 * (translation[2] - translation[0]) || Math.abs(newTranslation[1] - translation[1]) > 0.03 * (translation[3] - translation[1])) {\n          translation = newTranslation;\n          if (render.terrainToggle) {\n            terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer);\n          }\n          if (render.nodeToggle) {\n            device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array(translation), 0, 4);\n          }\n        }\n      }\n    };\n    controller.wheel = function (amt) {\n      var change = [amt / 10000, amt / 10000];\n      newTranslation = [newTranslation[0] + change[0], newTranslation[1] + change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]];\n      if (newTranslation[2] - newTranslation[0] > 0.01 && newTranslation[3] - newTranslation[1] > 0.01) {\n        translation = newTranslation;\n        if (render.terrainToggle) {\n          terrainGenerator!.computeTerrain(undefined, undefined, translation, render.rangeBuffer);\n        }\n        if (render.nodeToggle) {\n          device.queue.writeBuffer(viewBoxBuffer, 0, new Float32Array(translation), 0, 4);\n        }\n      } else {\n        newTranslation = translation;\n      }\n    };\n    controller.registerForCanvas(canvasRef.current);\n    var viewBoxBindGroup = device.createBindGroup({\n      layout: this.nodePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: viewBoxBuffer,\n          },\n        },\n      ],\n    });\n\n    const texture = device.createTexture({\n      size: [1200, 1200],\n      sampleCount: 4,\n      format: presentationFormat,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    const view = texture.createView();\n\n    var render = this;\n    function frame() {\n        // Sample is no longer the active page.\n        if (!canvasRef.current) return;\n\n        const commandEncoder = device.createCommandEncoder();\n\n        const renderPassDescriptor: GPURenderPassDescriptor = {\n        colorAttachments: [\n          {\n            view,\n            resolveTarget: context.getCurrentTexture().createView(),\n            loadValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\n            storeOp: \"discard\" as GPUStoreOp,\n          },\n        ],\n        };\n\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        if (render.terrainToggle) {\n          passEncoder.setPipeline(pipeline);\n          passEncoder.setVertexBuffer(0, dataBuf2D);\n          passEncoder.setBindGroup(0, render.bindGroup2D!);\n          passEncoder.draw(6, 1, 0, 0);\n        }\n        if (render.nodeToggle) {\n          passEncoder.setPipeline(render.nodePipeline!);\n          passEncoder.setVertexBuffer(0, render.nodePositionBuffer!);\n          passEncoder.setBindGroup(0, viewBoxBindGroup);\n          passEncoder.draw(render.nodeLength * 6, 1, 0, 0);\n        }\n        passEncoder.endPass();\n  \n        device.queue.submit([commandEncoder.finish()]);\n        requestAnimationFrame(frame);\n    }\n\n    requestAnimationFrame(frame);\n\n  }\n\n  setNodeData(nodeData : Array<number>) {\n    // TODO: Implement the translation and global range options\n    this.terrainGenerator!.computeTerrain(nodeData, undefined, undefined, this.rangeBuffer);\n    var nodePositions : Array<number> = [];\n    var radius : number = 0.01;\n    for (var i = 0; i < nodeData.length; i+=4) {\n      var x = nodeData[i+1] * 2 - 1;\n      var y = nodeData[i+2] * 2 - 1;\n      nodePositions.push(\n        x + radius, y - radius,\n        x - radius, y - radius,\n        x - radius, y + radius,\n        x + radius, y - radius,\n        x - radius, y + radius,\n        x + radius, y + radius\n      );\n    }\n    this.nodePositionBuffer = this.device.createBuffer({\n      size: nodePositions.length * 4,\n      usage: GPUBufferUsage.VERTEX,\n      mappedAtCreation: true\n    });\n    new Float32Array(this.nodePositionBuffer.getMappedRange()).set(nodePositions);\n    this.nodePositionBuffer.unmap();\n    this.nodeLength = nodeData.length / 4;\n\n    // this.nodeBindGroup = this.device.createBindGroup({\n    //   layout: this.nodePipeline!.getBindGroupLayout(1),\n    //   entries: [\n    //     {\n    //       binding: 0,\n    //       resource: {\n    //         buffer: this.terrainGenerator!.nodeDataBuffer,\n    //       }\n    //     }\n    //   ]\n    // });\n  }\n\n  setWidthFactor(widthFactor : number) {\n    this.terrainGenerator!.computeTerrain(undefined, widthFactor, undefined, this.rangeBuffer);\n  }\n\n  setPeakValue(value : number) {\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 0, new Float32Array([value]), 0, 1);\n  }\n\n  setValleyValue(value : number) {\n    this.device.queue.writeBuffer(this.uniform2DBuffer!, 4, new Float32Array([value]), 0, 1);\n  }\n\n  setGlobalRange() {\n    if (this.rangeBuffer) {\n      this.rangeBuffer = null;\n    } else {\n      this.rangeBuffer = this.device.createBuffer({\n        size: 2 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n      });    \n    }\n  }\n\n  toggleTerrainLayer() {\n    this.terrainToggle = !this.terrainToggle;\n  }\n\n  toggleNodeLayer() {\n    this.nodeToggle = !this.nodeToggle;\n  }\n\n  async onSave() {\n    var height = this.outCanvasRef.current!.height;\n    var width = this.outCanvasRef.current!.width;\n    const gpuReadBuffer = this.device.createBuffer({\n      size: width * height * 4,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n    console.log(width, height);\n    var commandEncoder = this.device.createCommandEncoder();\n    // Encode commands for copying buffer to buffer.\n    commandEncoder.copyBufferToBuffer(\n      this.terrainGenerator!.pixelValueBuffer /* source buffer */,\n      0 /* source offset */,\n      gpuReadBuffer /* destination buffer */,\n      0 /* destination offset */,\n      width * height * 4 /* size */\n    );\n\n    // Submit GPU commands.\n    const gpuCommands = commandEncoder.finish();\n    this.device.queue.submit([gpuCommands]);\n\n    // Read buffer.\n    await gpuReadBuffer.mapAsync(GPUMapMode.READ);\n    const arrayBuffer = gpuReadBuffer.getMappedRange();\n    var output = new Float32Array(arrayBuffer);\n    var context = this.outCanvasRef.current!.getContext('2d');\n    context!.drawImage(this.colormapImage, 0, 0);\n    var colorData = context!.getImageData(0, 0, 180, 1).data;\n    var imgData = context!.createImageData(width, height);\n    for (var i = 0; i < height; i++) {\n      for (var j = 0; j < width; j++) {\n        var index = j + i * width;\n        var colorIndex = Math.trunc(output[j + (height - 1 - i) * width] * 180) * 4;\n        imgData.data[index * 4] = colorData[colorIndex];\n        imgData.data[index * 4 + 1] = colorData[colorIndex + 1];\n        imgData.data[index * 4 + 2] = colorData[colorIndex + 2];\n        imgData.data[index * 4 + 3] = colorData[colorIndex + 3];\n      }\n    }\n    context!.putImageData(imgData, 0, 0);\n    this.outCanvasRef.current!.toBlob(function (b) { saveAs(b!, `terrain.png`); }, \"image/png\");\n  }\n\n}\nexport default Renderer;\n\n","import React from 'react';\nimport Sidebar from './Sidebar';\nimport { createRef, MutableRefObject } from 'react';\nimport Renderer from \"../webgpu/render\";\nimport colormap from './rainbow.png';\n\ntype PageState = {\n    widthFactor: number,\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    outCanvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    renderer: Renderer | null,\n}\nclass Page extends React.Component<{}, PageState> {\n    constructor(props) {\n        super(props);\n        this.state = {\n            widthFactor: 1000, \n            canvasRef: createRef<HTMLCanvasElement | null>(), \n            outCanvasRef: createRef<HTMLCanvasElement | null>(), \n            renderer: null\n        };\n    }\n\n    async componentDidMount() {\n        const adapter = (await navigator.gpu.requestAdapter())!;\n        const device = await adapter.requestDevice(); \n        var colormapImage = new Image();\n        colormapImage.src = colormap;\n        await colormapImage.decode();\n        const imageBitmap = await createImageBitmap(colormapImage);\n        this.setState({renderer: new Renderer(\n            adapter, device, this.state.canvasRef, \n            imageBitmap, colormapImage, this.state.outCanvasRef)\n        });\n    }\n\n    setNodeData(nodeData : Array<number>) {\n        this.state.renderer!.setNodeData(nodeData);\n    }\n\n    setWidthFactor(widthFactor : number) {\n        this.state.renderer!.setWidthFactor(widthFactor);\n    }\n\n    setPeakValue(value : number) {\n        this.state.renderer!.setPeakValue(value);\n    }\n\n    setValleyValue(value : number) {\n        this.state.renderer!.setValleyValue(value);\n    }\n\n    setGlobalRange() {\n        this.state.renderer!.setGlobalRange();\n    }\n\n    toggleNodeLayer() {\n        this.state.renderer!.toggleNodeLayer();\n    }\n\n    toggleTerrainLayer() {\n        this.state.renderer!.toggleTerrainLayer();\n    }\n\n    onSave() {\n        this.state.renderer!.onSave();\n    }\n  \n    render() {\n      return (\n        <div>\n            <Sidebar \n                setValleyValue={this.setValleyValue.bind(this)} \n                setPeakValue={this.setPeakValue.bind(this)} \n                setWidthFactor={this.setWidthFactor.bind(this)} \n                setNodeData={this.setNodeData.bind(this)} \n                setGlobalRange={this.setGlobalRange.bind(this)}\n                toggleNodeLayer={this.toggleNodeLayer.bind(this)}\n                toggleTerrainLayer={this.toggleTerrainLayer.bind(this)}\n                onSave={this.onSave.bind(this)}\n            />\n            <div className=\"canvasContainer\">\n                <canvas ref={this.state.canvasRef} width={800} height={800}></canvas>\n                <canvas hidden={true} ref={this.state.outCanvasRef} width={800} height={800}></canvas>\n            </div>\n        </div>\n      );\n    }\n  }\n\nexport default Page;","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAABCAYAAAB3yoT0AAAAOklEQVQokc3QsQrAIBBEwTEI+v9fG0E8e0kKu6se7HRbiFBR0X+azVpg4j36teWwx0px3Y2VkeK6K9uFnl0AGQ1BkQAAAABJRU5ErkJggg==\"","import './App.css';\nimport Page from './components/Page';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Page />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode >\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}